:PROPERTIES:
:ID:       7b4cf445-1b4b-4c3f-bc65-d6e3057f3784
:END:
#+title: ift6755-alloy
#+STARTUP: latexpreview inlineimages
#+date: [2022-02-26 Sat 16:14]

Alloy -
- Quantifiers - ~quantifier variable:type | formula~, curly braces for multiple constraints
  - ~formula~ evaluates to boolean
  - ~expression~ evaluates to relational value
    - ~all x:X | formula~ - Every ~x~ of type ~X~ satisfies ~formula~
      - If there are no ~X~, then this statement is trivially true
    - ~some x:X | formula~ - One or more ~x~ of type ~X~ satisfy ~formula~
      - If there are no ~X~, then this statement is trivially false
    - ~no x:X | formula~ - Exactly zero ~x~ of type ~X~ satisfy ~formula~
    - ~one x:X | formula~ - Exactly one ~x~ of type ~X~ satisfy ~formula~
    - ~lone x:X | formula~ - Exactly zero or one ~x~ of type ~X~ satisfy ~formula~

    - ~some X~ - There is at least one ~X~
    - ~no X~ - There are no ~X~'s
    - ~one X~ - There is exactly one ~X~
    - ~lone X~ - There are either zero or one ~X~'s


- Set operations
  - ~~~ - Not
  - ~+~ - Union, ~t~ is in ~p + q~ iff ~t~ is in ~p~ or ~t~ is in ~q~
  - ~&~ - Intersection ~t~ is in ~p & q~ iff ~t~ is in ~p~ and ~t~ is in ~q~
  - ~-~ - Subtraction ~t~ is in ~p - q~ iff ~t~ is in ~p~ but ~t~ is not in ~q~
  - ~in~ - Membership / subset, set membership and subsets denoted by ~in~, overloaded

  - ~*~ - Reflexive transitive closure, recursive (0 to n)
  - ~^~ - (Non-reflective) transitive closure (1 to n)

- Unions

#+begin_src java

  sig A {}
  // set of atoms A

  sig A {}
  sig B {}
  // disjoint sets A and B (no A & B)

  sig A, B {}
  // same as above

  sig B extends A {}
  // set B is a subset of A (B in A)

  sig B extends A {}
  sig C extends A {}
  // B and C are disjoint subsets of A
  // (B in A && C in A && no B & C)

  sig B, C extends A {}
  same as above

  abstract sig A {}
  sig B extends A {}
  sig C extends A {}
  // A partitioned by disjoint subsets B and C
  // (no B & C && A = (B + C))

  sig B in A {}
  // B is a subset of A â€“ not necessarily
  // disjoint from any other set

  sig C in A + B {}
  // C is a subset of the union of A and B

  one sig A {}
  lone sig B {}
  some sig C {}
  // A is a singleton set
  // B is a singleton or empty
  // C is a non-empty set

#+end_src

~n.(b.addr)~ == ~b.addr[n]~

- Signatures:

#+begin_src java

  sig name {
      // fields of signature
      // by default one
  } {
      // Appended fact constraints
      // implied all this:name { multi-line formulas }
      // implied this in formulas
      // universal fact for all instances of name
  }

#+end_src

- Relations

  - ~->~ - Ternary relation when used in fields block between the name of signature and the two items left and right of arrow
  - Multiplicity markings are used like this ~quantifier ->~ or this ~-> quantifier~
    - The side of the quantifier acts on the item at that side and dictates the multiplicity of that item with respect to the binary relation level
    - ~lone, one, some~ are usable quantifiers
    - No quantifiers remove any multiplicity constraint

- Misc

  - ~for n~ - Examine all examples whose top level signatures (parent classes, that do not extend) have up to ~n~ instances
  - ~assert name {...} ... check name~ - Property of the model that should be true, alloy searches for counterexamples
  - ~fact~ puts explicit constraint
  - ~run~ - alloy searches for appropriate models not counter examples

* Intro

** Everything is a relation

- Alloy uses relations for all data types (sets, scalars, tuples, etc...) and structures in space and time
- Key operator is *dot* join
  - Relational join
  - Field navigation
  - Function application

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220226161444-alloy.org_20220226_163122_x3vsVa.png]]

- Relations are easy to understand
  - Binary relation is a graph or a mapping
- Relations are easy to analyze
  - First order (tractable)
- Relations are uniform
  - Set of addresses associated with name ~n~ in set of books ~B~:
    - Alloy: ~n.(B.addr)~
    - OCL: ~B.addr[n] -> asSet()~

"There is no problem in computer science that cannot be solved by an extra level of indirection" - David Wheeler

** Non-specialized logic

No special constructs for state machines, traces, synchronization, concurrency

** Counter-examples and scope

Observations about design analysis
- Most assertions are wrong
- Most flaws have small counter-examples

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220226161444-alloy.org_20220226_163631_NBSmen.png]]

** Analysis by SAT

SAT - the quintessential hard problem
- SAT is hard, so reduce SAT to your problem

SAT - the universal constraint solver
- SAT is easy, so reduce your problem to SAT

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220226161444-alloy.org_20220226_163911_K6dPmf.png]]

SAT performance follows a similar trend

