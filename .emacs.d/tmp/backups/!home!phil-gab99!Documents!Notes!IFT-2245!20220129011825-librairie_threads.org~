:PROPERTIES:
:ID:       60916aa4-ce84-4415-a491-38ee855b55c8
:END:
#+title: ift2245-librairie-threads
#+STARTUP: latexpreview inlineimages
#+date: [2022-01-29 Sat 01:18]

* Librairie de Thread

La librairie de threads fournit au programmeur un *API* pour *créer et gérer* des threads

- Pthreads POSIX (utilisateur ou noyau)
- Librairie de threads Windows (noyau)
- Librairie de threads Java (interfaces JVM avec la librairie de threads du système d'exploitation)

Les threads parent-enfant peuvent être
- *Synchrone* $\Rightarrow$ Le thread parent doit attendre la fin de tous les threads enfants (par exemple, partage des données et combinaison des résultats)
- *Asynchrone* $\Rightarrow$ Le parent poursuit son exécution, ce qui est souvent le cas pour les services de type serveur

** Mécanismes de thread

- *Structure de donnée* de thread - Identifier, suivre l'utilisation, PC, pointeur de pile, registres, autres attributs, etc...
- *Création et gestion* - Généralement eﬀectué via un callback avec des arguments vers une procédure
  - Le PC pointe vers la première instruction du callback
- *Terminaison* - Les résultats peuvent être transmis de l'enfant au parent
  - C'est la seule façon dont le parent est diﬀérent de l'enfant
- *Coordination* entre les threads exécutés simultanément dans le même espace d’adressage
  - Pas besoin de mécanisme IPC comme dans le cas des processus
  - Gestion de coordination est beaucoup plus importante par contre

** Pthreads

- Structure de donnée - ~pthread_t~
- Création et gestion -

#+begin_src c

  /**
   * @param thread Un pthread
   * @param attr Liste d'attributs du thread
   * @param proc Une procédure à exécuter dans l'enfant
   * @param arg Arguments de la procédure
   */
  int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*proc)(void*), void* arg);

#+end_src

- Terminaison -

#+begin_src c

  /**
   * Semblable au `wait` dans le cas d'un processus
   *
   * @param thread Un pthread
   * @param status Comme pour la fonction wait
   */
  int pthread_join(pthread_t thread, void** status);

#+end_src

*** Pthread attributs

Exemples d'attributs:

- Taille de la pile
- Héritage
- Politique de planification
- Étendue
- Priorité
- Joinable - Si les threads ne sont pas joignables, ils sont appelés *détachés* (ils ne peuvent plus être joints)

Les attributs sont gérés par un API ~pthread_attr_init~:

#+begin_src c

  /**
   * @param attr Les attributs utilisés pour créer le thread
   */
  int pthread_attr_init(pthread_attr_t* attr);

  pthread_attr_(set/get) (attribute(...));

#+end_src

*** Annulation de threads

Mettre fin à un thread *avant* qu'il ne soit terminé

- Le thread à annuler est appelé le *thread cible* (target thread)
- Deux approches générales:
  - *L'annulation asynchrone* met fin au thread cible *immédiatement*
  - *L'annulation diﬀérée* permet au thread cible de vérifier périodiquement s'il doit être annulé
- Des précautions doivent être prises pour les données partagées, les ressources allouées, etc.

#+begin_src c

  int pthread_cancel(tid);

#+end_src

 Cas d'utilisation -
 - Tâche n'est plus nécessaire (déjà complétée par un autre thread par exemple)
 - Thread utilise trop de ressources

*** Exemple Pthreads

#+begin_src c

  int sum; // this data is shared by the thread(s)
  void *runner(void* param); // the thread

  int main(int argc, char *argv[]) {
      pthread_t tid;                               // the thread identifier
      pthread_attr_t attr;                         // set of attributes for the thread
      pthread_attr_init(&attr);                    // get default attributes
      pthread_create(&tid, &attr, runner, rve[1]); // create the thread
      pthread_join(tid, NULL);                     // wait for the thread to exit
      printf("sum = %d\n", sum);
      return 0;
  }

  /**
   * The thread will begin control in this function
   * Sums values from 1 to param value
   */
  void* runner(void* param) {
      int i, upper = atoi(param);
      sum = 0;

      if (upper > 0)
          for (i = 1; i <= upper; i++) sum += i;

      pthread_exit(0);
  }

#+end_src

** Java Threads

Les threads en Java sont géré par le JVM

Généralement implémenter en utilisant le modèle de threads fourni par le système d'exploitation sous-jacent

- Java threads peuvent être créés par:
  - Étendre la classe ~Thread~
  - Implémenter l'interface ~Runnable~

#+begin_src java

  public interface Runnable {
      public abstract void run();
  }

#+end_src

** Threading implicite

De plus en plus populaire avec l'augmentation du nombre de threads
L'exactitude du programme est plus difficile avec des threads explicites

- La *création* et la *gestion des threads* peuvent (et devraient peut-être) être faites de préférence par des compilateurs et des librairies d'exécution plutôt que par des programmeurs
  - La création de threads et la destruction nécessite du temps
  - Sans limites, trop de threads pourraient épuiser les ressources du système d'exploitation
    
Deux exemples:
- Thread pools
- OpenMP

*** Thread pools

- Lorsque le processus démarre, créer un nombre de threads dans un "pool" où ils attendent le travail
  - Thread *réveillé* pour l'utilisation, puis *retourné au pool* une fois terminé
  - Si aucun n'est disponible, attendre qu'un thread *retourne dans le pool*

- Avantages:
  - Habituellement un peu plus rapide pour traiter une requête avec un thread existant que de créer un nouveau thread
  - Permet de limiter le nombre de threads d'une application à la taille du "pool"
  - Séparation des tâches à eﬀectuer à partir de la *mécanique de création de tâche* permet diﬀérentes stratégies pour exécuter la tâche
    - Par exemple, les tâches peuvent être planifiées pour être exécutées après un délai ou périodiquement - traité par le *thread pool*

*** OpenMP

Fournit un support pour la *programmation parallèle* dans des environnements à mémoire partagée
Identifie les *régions parallèles* - Des blocs de code pouvant fonctionner en parallèle

#+begin_src c

  #pragma omp parallel

#+end_src

- Créer autant de threads que de coeurs qui seront exécutés simultanément et qui se termineront lorsque le thread sera fermé
- Le programmeur peut également contrôler le nombre de threads

#+begin_src c

  // Compilateur essaie de paralléliser la boucle for si possible
  #pragma omp parallel for

  for (i = 0; i < N; i++) c[i] = a[i] + b[i];

#+end_src

- Exécuter pour une boucle en parallèle et le programmeur peut déterminer si les données sont partagées ou privées

#+begin_src c

  #include <omp.h>
  #include <stdio.h>

  int main(int argc, char* argv[]) {

      // Sequential code

      #pragma omp parallel
      {
          printf("Iam a parallel region");
      }

      // Sequential code

      return 0;
  }

#+end_src

* Les ~fork()~ et ~exec()~

Est-ce que ~fork()~ fait une copie de juste le thread où il est appeler ou tous les threads dans le processus?
- Les versions de UNIX ont deux versions de fork (c'est-à-dire, le *thread appelant* OU le *processus appelant*)

~exec()~ fonctionne normalement comme d'habitude - Remplace le processus en cours, y compris *tous les threads*

Exemple:

#+begin_src c :tangle ~/Projects/workspace/c/threads-posix.c

  #include <stdio.h>
  #include <unistd.h>
  #include <pthread.h>
  #include <sys/types.h>
  #include <sys/wait.h>

  int value = 0;
  void *runner(void *param);

  int main(int argc, char *argv[]) {
      pid_t pid;
      pthread_t tid;
      pthread_attr_t attr;
      pid = fork();

      if (pid == 0) {
          pthread_attr_init(&attr);
          pthread_create(&tid, &attr, runner, NULL);
          pthread_join(tid, NULL);
          printf("LINE A value = %d\n", value);
      } else if (pid > 0) {
          wait(NULL);
          printf("LINE D value = %d\n",value);
      }

      printf("LINE E value = %d\n", value);
  }

  void *runner(void *param) {
      value += 5;
      char buffer[100];
      sprintf(buffer, "LINE C value = %d", value);
      execlp("echo","echo", buffer, NULL);
      pthread_exit(0);
  }

  // Output

  // LINE C value = 5
  // LINE A value = 5
  // LINE E value = 5
  // LINE D value = 0
  // LINE E value = 0

#+end_src

* Linux threads

- Linux leur réfère comme des *tâches* plutôt que des threads
- La création de thread est eﬀectuée via l'appel système de ~clone()~
- ~clone()~ permet à une tâche enfant de partager l'espace d'adressage de la tâche parente (processus)
- Les flags contrôlent le comportement:

| flag          | meaning                           |
|---------------+-----------------------------------|
| CLONE_FS      | File-system information is shared |
| CLONE_VM      | The same memory space is shared   |
| CLONE_SIGHAND | Signal handlers are shared        |
| CLONE_FILES   | The set of open files is shared   |

~struct task_struct~ pointe vers des structures de données de processus (partagées ou uniques)

- ~fork()~ fait appel à ~clone()~ sans partager l'espace adressage
- ~pthread_create()~ fait appel à ~clone()~ et partage l'espace adressage

Abstractions fournies pas UNIX (plutôt Linux)
- À un très bas niveau, les threads et les processus sont traités de la même façon, vu comme des tâches
- Se différencient sur le partage de données
