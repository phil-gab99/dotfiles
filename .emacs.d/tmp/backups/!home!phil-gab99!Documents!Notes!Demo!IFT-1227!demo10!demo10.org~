#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline \n:t
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: IFT-1227 Demo 10
#+date: <2022-03-31 Thu>
#+author: Philippe Gabriel
#+email: philippe.gabriel.1@umontreal.ca
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.0.91 (Org mode 9.5.2)
#+cite_export:

* Composants numériques

** Additionneur 1-bit

*** Half-adder

| A | B | C_out | S |
|---+---+-------+---|
| 0 | 0 |       |   |
| 0 | 1 |       |   |
| 1 | 0 |       |   |
| 1 | 1 |       |   |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;


#+end_src

**** Solution

| A | B | C_out | S |
|---+---+-------+---|
| 0 | 0 |     0 | 0 |
| 0 | 1 |     0 | 1 |
| 1 | 0 |     0 | 1 |
| 1 | 1 |     1 | 0 |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity half_adder is
    port(A, B: in STD_LOGIC;
         C_out, S: out STD_LOGIC);
  end half_adder;

  architecture synth of half_adder is
  begin
    C_out <= A and B;
    S <= A xor B;
  end synth;

#+end_src

*** Full-adder

**** Comportemental

| C_in | A | B | C_out | S |
|------+---+---+-------+---|
|    0 | 0 | 0 |       |   |
|    0 | 0 | 1 |       |   |
|    0 | 1 | 0 |       |   |
|    0 | 1 | 1 |       |   |
|    1 | 0 | 0 |       |   |
|    1 | 0 | 1 |       |   |
|    1 | 1 | 0 |       |   |
|    1 | 1 | 1 |       |   |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;


#+end_src

***** Solution


| C_in | A | B | C_out | S |
|------+---+---+-------+---|
|    0 | 0 | 0 |     0 | 0 |
|    0 | 0 | 1 |     0 | 1 |
|    0 | 1 | 0 |     0 | 1 |
|    0 | 1 | 1 |     1 | 0 |
|    1 | 0 | 0 |     0 | 1 |
|    1 | 0 | 1 |     1 | 0 |
|    1 | 1 | 0 |     1 | 0 |
|    1 | 1 | 1 |     1 | 1 |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity full_adder_comp is
    port(A, B, C_in: in STD_LOGIC;
         C_out, S: out STD_LOGIC);
  end full_adder_comp;

  architecture synth of full_adder_comp is
  begin
    C_out <= (A and B) or (A and C_in) or (B and C_in);
    S <= A xor B xor C_in;
  end synth;

#+end_src

**** Structurel

[[/home/phil-gab99/Documents/Notes/Demo/IFT-1227/demo10/demo10.org_20220330_174916_gc57qc.png]]

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;


#+end_src

***** Solution

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity full_adder_struct is
    port(A, B, C_in: in STD_LOGIC;
         C_out, S: out STD_LOGIC);
  end full_adder_struct;

  architecture synth of full_adder_struct is
    component half_adder
      port(A, B: in STD_LOGIC;
           C_out, S: out STD_LOGIC);
    end component;

    component or_gate
      port(A, B: in STD_LOGIC;
           Y: out STD_LOGIC);
    end component;
    signal T1, T2, T3: STD_LOGIC;
  begin
    half_adder1: half_adder port map(A, B, T1, T2);
    half_adder2: half_adder port map(T1, C_in, S, T3);
    or_gate1: or_gate port map(T3, T2, C_out);
  end synth;

#+end_src

** Soustracteur 1-bit

*** Half-subtractor

| A | B | N_out | D |
|---+---+-------+---|
| 0 | 0 |       |   |
| 0 | 1 |       |   |
| 1 | 0 |       |   |
| 1 | 1 |       |   |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;


#+end_src

**** Solution

| A | B | N_out | D |
|---+---+-------+---|
| 0 | 0 |     0 | 0 |
| 0 | 1 |     1 | 1 |
| 1 | 0 |     0 | 1 |
| 1 | 1 |     0 | 0 |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity half_subtractor is
    port(A, B: in STD_LOGIC;
         D, N_out: out STD_LOGIC);
  end half_subtractor;

  architecture synth of half_subtractor is
  begin
    D <= A xor B;
    N_out <= (not A) and B;
  end synth;

#+end_src

*** Full-subtractor

| N_in | A | B | N_out | D |
|------+---+---+-------+---|
|    0 | 0 | 0 |       |   |
|    0 | 0 | 1 |       |   |
|    0 | 1 | 0 |       |   |
|    0 | 1 | 1 |       |   |
|    1 | 0 | 0 |       |   |
|    1 | 0 | 1 |       |   |
|    1 | 1 | 0 |       |   |
|    1 | 1 | 1 |       |   |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;


#+end_src

**** Solution

| N_in | A | B | N_out | D |
|------+---+---+-------+---|
|    0 | 0 | 0 |   0   | 0 |
|    0 | 0 | 1 |   1   | 1 |
|    0 | 1 | 0 |   0   | 1 |
|    0 | 1 | 1 |   0   | 0 |
|    1 | 0 | 0 |   1   | 1 |
|    1 | 0 | 1 |   1   | 0 |
|    1 | 1 | 0 |   0   | 0 |
|    1 | 1 | 1 |   1   | 1 |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity full_subtractor_comp is
    port(A, B, N_in: in STD_LOGIC;
         D, N_out: out STD_LOGIC);
  end full_subtractor_comp;

  architecture synth of full_subtractor_comp is
  begin
    D <= A xor B xor N_in;
    N_out <= (not A and (B or N_in)) or (B and N_in);
  end synth;

#+end_src

** Comparateur Égalité 1-bit

| A | B | E |
|---+---+---|
| 0 | 0 |   |
| 0 | 1 |   |
| 1 | 0 |   |
| 1 | 1 |   |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;


#+end_src

*** Solution

| A | B | E |
|---+---+---|
| 0 | 0 | 1 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity equality_comp is
    port(A, B: in STD_LOGIC;
         E: out STD_LOGIC);
  end equality_comp;

  architecture synth of equality_comp is
  begin
    E <= not (A xor B);
  end synth;

#+end_src

** SLT 1-bit

| A | B | L |
|---+---+---|
| 0 | 0 |   |
| 0 | 1 |   |
| 1 | 0 |   |
| 1 | 1 |   |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;


#+end_src

*** Solution

| A | B | L |
|---+---+---|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 0 |
| 1 | 1 | 0 |

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity slt is
    port(A, B: in STD_LOGIC;
         L: out STD_LOGIC);
  end slt;

  architecture synth of slt is
  begin
    L <= not A and B;
  end synth;

#+end_src

* Arithmetic and Logic Unit (ALU)

[[/home/phil-gab99/Documents/Notes/Demo/IFT-1227/demo10/demo10.org_20220330_170435_Xs0yqx.png]]

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  

#+end_src

** Solution

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity alu is
    port(F: in STD_LOGIC_VECTOR(2 downto 0);
         A, B: in STD_LOGIC;
         C_out: out STD_LOGIC;
         Y: out STD_LOGIC);
  end alu;

  architecture synth of alu is
    signal tmp: STD_LOGIC_VECTOR(1 downto 0);
  begin
    process(F, A, B)
    begin
      case F is
        when "000" => tmp <= A and B;
        when "001" => tmp <= A or B;
        when "010" => tmp <= A + B;
        when "100" => tmp <= A and not B;
        when "101" => tmp <= A or not B;
        when "110" => tmp <= A - B;
        when "111" =>
          if A = '0' and B = '1' then
            tmp <= "01";
          else
            tmp <= "00";
          end if;
        when others => tmp <= "00"
      end case;
    end process ;
    C_out <= '1' when tmp(1) = '1' else '0';
    Y <= tmp(0);
  end synth;

#+end_src
