:PROPERTIES:
:ID:       55b0edcb-7571-4929-961f-96719daa9c74
:END:
#+title: ift2935-vues-fonctions-triggers-autres
#+STARTUP: latexpreview inlineimages
#+date: [2022-03-16 Wed 02:07]

* Déclarations

Définition de la fonction:

#+begin_src sql

  CREATE FUNCTION trigger_function() RETURN trigger AS

#+end_src

- Dans le corps de la fonction, ~OLD~ représente la ligne dans la table avant la miste à jour, ~NEW~ la ligne correspondante à la mise à jour demandée
- Création du trigger:

  #+begin_src sql 

  CREATE TRIGGER <name> (BEFORE | AFTER | INSTEAD OF) {event [OR ...]}
      ON <table/view-name>
      [FOR [EACH] {ROW | STATEMENT}]
      EXECUTE PROCEDURE trigger_function

  #+end_src

- Avec ~INSTEAD OF~, il faut traiter ligne par ligne (~FOR EACH ROW~)

** Exemple

On a les tables

#+begin_src sql

  CREATE TABLE employees(
      emp_id SMALLSERIAL PRIMARY KEY,
      first_name VARCHAR(40) NOT NULL,
      last_name VARCHAR(40) NOT NULL
  );

  CREATE TABLE employee_audits(
      aud_id SMALLSERIAL PRIMARY KEY,
      employee_id INT NOT NULL,
      last_name VARCHAR(40) NOT NULL,
      changed_on TIMESTAMP(6) NOT NULL
  );

#+end_src

- On veut garder dans ~employee_audits~ les changements de noms d'employ'es, avec l'ancien nom, ainsi que la date où le nom est devenu périmé (date de changement):

  #+begin_src sql

  CREATE OR REPLACE FUNCTION log_last_name_changes()
  RETURNS TRIGGER AS $BODY$
  BEGIN
      IF NEW.last_name <> OLD.last_name THEN
          INSERT INTO employee_audits(employee_id, last_name, changed_on)
              VALUES (OLD.emp_id, Old.last_name, NOW());
      END IF;
      RETURN NEW;
  END
  $BODY$ LANGUAGE plpgsql;

  #+end_src

Définition du trigger:

#+begin_src sql

  CREATE TRIGGER last_name_changes
      BEFORE UPDATE
      ON employees
      FOR EACH ROW
      EXECUTE PROCEDURE log_last_name_changes();

#+end_src

Insertion de valeurs:

#+begin_src sql

  INSERT INTO employees(first_name, last_name) VALUES ('John', 'Doe'), ('Lily', 'Bush');

#+end_src

~SELECT * FROM employees~ retourne:

| emp_id | first_name | last_name |
|--------+------------+-----------|
|      1 | John       | Doe       |
|      2 | Lily       | Bush      |

Effet d'un ~UPDATE~:
- La mise à jour ~UPDATE employees SET last_name = 'Brown' WHERE emp_id = 2;~ a pour effet de donner les tables ~employees~ et ~employee_audits~ suivantes:

| emp_id | first_name | last_name |
|--------+------------+-----------|
|      1 | John       | Doe       |
|      2 | Lily       | Brown     |

| aud_id | employee_id | lasT_name | changed_on                |
|--------+-------------+-----------+---------------------------|
|      1 |           2 | Bush      | 2019-03-19 19:51:45.27195 |

- Avec psql, on peut voir la trace avec ~psql -h localhost -a < updt_table.sql~

* Updates en utilisant des VIEW

On a les trois tables suivantes
~CREATE TABLE noms(id INT, Nom TEXT);~
~CREATE TABLE notes(id INT, Note INT);~
~CREATE TABLE villes(id INT, Ville TEXT);~

- Ces tables contiennent pour chaque étudiant un nom, une note et une ville de la personne d'identificateur ~id~
- La vue utile qui nous intéresse regroupe le tout et est clairement donnée par:
  ~CREATE VIEW resultats AS SELECT * FROM nom NATURAL JOIN villes NATURAL JOIN notes;~
- Elle a quatre colonnes: ~id, Nom, Note, Ville~ pour chaque étudiant
- A priori, on ne peut pas l'utiliser pour faire un ~UPDATE~

Avec ~SELECT * FROM resultats~, on a:

| id | nom     | ville     | note |
|----+---------+-----------+------|
|  1 | Pierre  | Montreal  |   80 |
|  2 | Paul    | Quebec    |   75 |
|  3 | Jean    | Sorel     |   90 |
|  4 | Jacques | Vaudreuil |  100 |

- Si on veut changer la note de Pierre en SQL, il faut retrouver son ~id~ qui est 1, ensuite changer sa note avec un ~UPDATE~ de la table ~notes~ pour le ~id = 1~
- Pourquoi ne pas plutôt donner les indications à postgres pour faire ce travail?
- C'est ce que permettent les déclencheurs
- Il est possible de faire un ~UPDATE~ des tables sous-jacentes en utilisant la vue ~resultats~

On ajoute un ~TRIGGER~ sur ~UPDATE~ (en vérifiant si les valeurs ont changés avant d'agir)

#+begin_src sql

  CREATE OR REPLACE FUNCTION resultats_trig_fn()
  RETURNS trigger AS $BODY$
  BEGIN
      UPDATE notes SET Note = NEW.Note WHERE id = NEW.id;
      UPDATE villes SET Ville = NEW.Ville WHERE id = NEW.id;
      UPDATE noms SET Nom = New.Nom WHERE id = NEW.id;
      RETURN NEW;
  END;
  $BODY$ LANGUAGE plpgsl

  CREATE TRIGGER resultats_trig
      INSTEAD OF UPDATE ON resultats
      FOR EACH ROW
      EXECUTE PROCEDURE resultats_trig_fn();

#+end_src

Si on exécute
~SELECT * FROM resultats ORDER BY id;~
~UPDATE resultats SET Note = 90 WHERE Nom = 'Pierre';~
~SELECT * FROM resultats ORDER BY id;~
On obtient:

| id | nom     | ville     | note |
|----+---------+-----------+------|
|  1 | Pierre  | Montreal  |   80 |
|  2 | Paul    | Quebec    |   75 |
|  3 | Jean    | Sorel     |   90 |
|  4 | Jacques | Vaudreuil |  100 |

| id | nom     | ville     | note |
|----+---------+-----------+------|
|  1 | Pierre  | Montreal  |   90 |
|  2 | Paul    | Quebec    |   75 |
|  3 | Jean    | Sorel     |   90 |
|  4 | Jacques | Vaudreuil |  100 |

** Vues pouvant être mises à jours sans triggers

Un SGBD peut permettre des modifications sur une vue sans triggers
Avec PostgreSQL, les conditions sont:
- La vue doit avoir exactement une entrée dans le ~FROM~ correspondant à une table ou une autre vue modifiable (donc pas de jointure pour définir la vue)
- La définition de la vue ne doit pas contenir de ~WITH~, ~DISTINCT~, ~GROUP BY~, ~HAVING~, ~LIMIT~, ~OFFSET~ au top-level
- La définition de la vue ne doit pas contenir d'opérations ensemblistes (~UNION~, ~INTERSECT~, ~EXCEPT~) au top-level
- Le ~SELECT~ de la vue doit se faire sur des attributs, pas des fonctions

*** Exemple

Avec la table ~employee~ contenant les champs suivantes:
~employee(fname, lname, ssn, bdate, address, sex, salary, superssn, dno)~
La vue ~emp~ définie par:
~CREATE VIEW emp AS SELECT ssn, fname, lname, salary, dno, superssn FROM employee;~
permet de modifier le nom, prénom, salaire, et même de changer son département pourvu que le département existe

* Vues matérialisées

Les vues matérialisées gardent en "cache" le résultat de requêtes dispendieuses et permettent de mettre à jour périodiquement ces valeurs
- Elles servent pour un accès rapide à la table virtuelle
- On les crée comme suit:
  ~CREATE MATERIALIZED VIEW <view_name> AS <SQL query> WITH [NO] DATA;~
  - Avec ~WITH DATA~ les données sont chargées à la création
  - On met la vue à jour avec ~REFRESH MATERIALIZED VIEW <view_name>~
  - Un ~SELECT * FROM <view_name>~ ne retourne pas le résultat de la requête définissant la vue mais la dernière valeur retournée par la requête lors d'un ~REFRESH~
- Ce type de vue n'est pas dans un standard SQL - Elles ont été introduites dans Oracle et on les retrouve dans plusieurs SGBD
