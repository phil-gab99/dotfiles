:PROPERTIES:
:ID:       5994a331-9763-423e-9b38-37cb7f0b14fc
:END:
#+title: ift2935-transctions-ordonnancements
#+STARTUP: latexpreview inlineimages
#+date: [2022-03-31 Thu 11:33]

* Ordonnancements équivalents

- On suppose que chaque transaction prise isolément (si aucune n'exécute en même temps) laisse la base cohérente
- Si on soumet les transactions $T_1$, $T_2$ et $T_3$, le SGBD pourrait décider de les mettre en ordre (ex.: $T_2, T_1, T_3$ et exécuter toutes les instructions de $T_2$ puis celles de $T_1$, puis celles de $T_3$)
  - Un tel ordonnancement est dit *séquentiel* (serial schedule)

** Ordonnancement séquentiel

$T_1$ fait un transfert de $50 et $T_2$ un transfert de 10% de $A$ vers $B$

Ci-dessous la transaction $T_1$ s'exécute avant $T_2$
\begin{tabular}{l | l | c | c}
$T_1$ & $T_2$ & $A$ & $B$ \\
\hline
$R(A); A \gets A - 50$ & & 1000 & 2000 \\
$W(A)$ & & 950 & 2000 \\
$R(B)$ & & & \\
$B \gets B + 50; W(B)$ & & 950 & 2050 \\
& $R(A)$ & & \\
& $t \gets A \times 0.1; A \gets A - t; W(A)$ & 855 & 2050 \\
& $R(B)$ & & \\
& $B \gets B + t; W(B)$ & 855 & 2145
\end{tabular}

- Garantit la propriété d'isolation
- Pas optimal $\to$ Plusieurs transactions peuvent être bloquées par une longue transaction

** Ordonnancement sérialisable

Ci-dessous, les actions de $T_1$ n'interfèrent pas avec celles de $T_2$ et vice-versa
\begin{tabular}{l | l || c | c}
$T_1$ & $T_2$ & $A$ & $B$ \\
\hline
$R(A); A \gets A - 50$ & & 1000 & 2000 \\
$W(A)$ & & 950 & 2000 \\
& $R(A)$ & & \\
& $t \gets A \times 0.1; A \gets A - t; W(A)$ & 855 & 2000 \\
$R(B)$ & & & \\
$B \gets B + 50; W(B)$ & & 855 & 2050 \\
& $R(B)$ & & \\
& $B \gets B + t; W(B)$ & 855 & 2145
\end{tabular}

- Cet ordonnancement n'est pas séquentiel
- Mais il est équivalent à un ordonnancement séquentiel
- Il garantit donc la propriété d'isolement

C'est un ordonnancement *sérialisable par permutation* (voir plus bas)

** Ordonnancement non-sérialisable

Ci-dessous, les actions de $T_1$ interfèrent avec celles de $T_2$, et vice versa
\begin{tabular}{l | l || c | c}
$T_1$ & $T_2$ & $A$ & $B$ \\
\hline
$R(A); A \gets A - 50$ & & 1000 & 2000 \\
& $R(A)$ & & \\
& $t \gets A \times 0.1; A \gets A - t; W(A)$ & 900 & 2000 \\
& $R(B)$ & & \\
$W(A)$ & & 950 & 2000 \\
$R(B)$ & & & \\
$B \gets B + 50; W(B)$ & & 950 & 2050 \\
& $B \gets B + t; W(B)$ & 950 & 2100
\end{tabular}

- L'état final est inconsistant - Le total est $3050
- Cet ordonnancement n'est donc pas sérialisable

Cet ordonnancement n'est pas *sérialisable par permuation* (voir plus bas)

\begin{tabular}{l | l || c | c}
$T_1$ & $T_2$ & $A$ & $B$ \\
\hline
$R(A); A \gets A - 50$ & & 1000 & 2000 \\
& $R(A)$ & & \\
& $t \gets A \times 0.1; A \gets A - t; W(A)$ & 900 & 2000 \\
$W(A)$ & & 950 & 2000 \\
$R(B)$ & & & \\
$B \gets B + 50; {\color{green} W(B)}$ & & 950 & 2050 \\
& ${\color{green} R(B)}$ & & \\
& $B \gets B + t; W(B)$ & 950 & 2100
\end{tabular}

- Cas de lecture impropre
- Il existe également le cas d'écriture écrasée

** Anomalies d'ordonnancements concurrents

$C$: ~Commit,~
$Ab:$ ~Abort/Rollback~

*Lecture impropre* (dirty read) $\Rightarrow$ Lecture d'une écriture non confirmée (uncommited) d'une transaction concurrente - conflits ~WR~
$T_1: \qquad \dots, {\color{green} W(A)} \qquad \qquad \qquad \qquad R(B), W(B), Ab$
$T_2: \qquad \qquad \qquad \quad {\color{green} R(A)}, W(A), C$

*Lecture non répétable* $\Rightarrow$ Conflits ~RW~ d'une valeur confirmée
$T_1: \qquad {\color{green} R(A)} \qquad \qquad \qquad \qquad \qquad {\color{green} R(A)}, W(A), C$
$T_2: \qquad \qquad \quad R(A), \dots, {\color{green} W(A), C}$

*Écrasement d'une écriture non confirmée* $\Rightarrow$ Conflits ~WW~
$T_1: \qquad {\color{green} W(A)} \qquad \qquad \qquad \qquad W(B), C$
$T_2: \qquad \qquad \quad {\color{green} W(A)}, W(B), C$

- Si on interdit les ordonnancements concurrents, une transaction longue peut bloquer toutes les autres
- On veut permettre les ordonnancements concurrents sans compromettre la propriété d'isolement (le résultat doit être le même que celui d'au moins un ordonnancement non concurrent)
- Il faut par conséquent gérer les accès concurrents aux mêmes données

** Sérialisabilité par permutation (conflict serializability)

Il s'agit d'une condition suffisante (et facilement vérifiable) de sérialisabilité
- Les opérations sur deux variables distinctes sont permutables:
  \begin{tabular}{c | c}
  $T_1$ & $T_2$ \\
  \hline
  $W(A)$ & \\
  & $W(B)$
 \end{tabular}

  équivaut à

  \begin{tabular}{c | c}
  $T_1$ & $T_2$ \\
  \hline
  & $W(B)$ \\
  $W(A)$ &
  \end{tabular}

- Deux lectures sur une même variables sont permutables:

  \begin{tabular}{c | c}
  $T_1$ & $T_2$ \\
  \hline
  $R(A)$ & \\
  & $R(A)$
  \end{tabular}

  équivaut à

  \begin{tabular}{c | c}
  $T_1$ & $T_2$ \\
  \hline
  & $R(A)$ \\
  $R(A)$ &
  \end{tabular}

- Tous les autres cas sont non permutables (conflictuels)
  
L'ordonnancement est (par définition) *sérialisable par permutation* si et seulement si on peut obtenir un ordonnanement sériel par une suite de permuations admissibles

** Test de sérialisabilité par permutation

On fait un graphe, dit de précédence, dont les sommets sont toutes les transactions $T_1, \dots, T_n$ concurrentes
- Il y a une arête de $T_i$ à $T_j$ s'il y a une paire conflictuelle dans $T_i$ et $T_j$ dont l'exécution dans $T_i$ précède celle dans $T_j$
- L'ordonnancement est sérialisable si et seulement si le graphe de précédence est sans cycle
- Tout tri topologique du graphe donne alors lieu à un ordonnancement sériel équivalent

*** Exemple

\begin{tabular}{l l l l l}
$T_1:$ & ${\color{green} R(A)}$ & & $W(A), R(B), {\color{yellow} W(B)}, C$ & \\
$T_2:$ & & $R(A), {\color{green} W(A)}, {\color{yellow} R(B)}$ & & $W(B), C$
\end{tabular}

- Un $T_1: R(A), \dots T2: W(A)$ justifie une arête de $T_1$ à $T_2$
- Un $T_2: R(B), \dots T_1: W(B)$ justifie une arête de $T_2$ à $T_1$
Le graphe est donc:

[[/home/phil-gab99/Documents/Notes/IFT-2935/20220331113350-transctions_ordonnancements.org_20220331_125649_bJOmAA.png]]

- Il y a donc un cycle - Ce n'est pas sérialisable par permutation

Un ordonnancement peut être sérialisable sans être sérialisable par permutation, cas de l'exemple suivant:

\begin{tabular}{l l l l l}
$T_1:$ & $R(A)$ & & $W(A), C$ & \\
$T_2:$ & & $W(A), C$ & & \\
$T_3:$ & & & & $W(A), C$
\end{tabular}

- Peu importe comment $T_1$ et $T_2$ sont entrelacés, c'est $T_3$ qui a le dernier mot

** Équivalence de vue

\begin{tabular}{l l l l l l}
& $T_1:$ & $R(A)$ & & $W(A)$ & \\
$O_1 =$ & $T_2:$ & & $W(A)$ & & \\
& $T_3:$ & & & & $W(A)$
\end{tabular}

\begin{tabular}{l l l l l l}
& $T_1:$ & $R(A), W(A)$ & & \\
$O_2 =$ & $T_2:$ & & $W(A)$ & & \\
& $T_3:$ & & & & $W(A)$
\end{tabular}

- Deux ordonnancements $O_1$ et $O_2$ sont équivalents en vue si
  - Pour toutes les transactions $T_i$, si $T_i$ lit la valeur initiale de $A$ dans $O_1$, $T_i$ lit aussi la valeur initiale de $A$ dans $O_2$ (pour toute valeur $A$)
  - Si $T_i$ lit une valeur de $A$ écrite par une autre transaction $T_j$ dans $O_1$, alors $T_i$ lit cette même valeur de $A$ dans l'ordonnancement $O_2$
  - Si $T_i$ écrit la valeur finale de $A$ dans l'ordonnancement $O_1$, $T_i$ écrit aussi la valeur finale de $A$ dans $O_2$

Un ordonnancement est *sérialisable en vue* s'il est équivalent en vue à un ordonnancement sériel
