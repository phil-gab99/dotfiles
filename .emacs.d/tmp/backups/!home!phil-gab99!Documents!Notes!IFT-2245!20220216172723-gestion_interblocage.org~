:PROPERTIES:
:ID:       a94aaebe-68a5-4089-891e-74aefb05f3b6
:END:
#+title: ift2245-gestion-interblocage
#+STARTUP: latexpreview inlineimages
#+date: [2022-02-16 Wed 17:27]

* Gestion des interblocages

Trois options
- Option 1 - S'assurer que le système n'atteindra jamais un état d'interblocage
  - *Prévention* $\to$ S'assurer qu'au moins une condition nécessaire ne tient pas
    - Le système a été construit de sorte à prévenir cela, que l'une des conditions ne sera jamais respectée par construction
  - *Évitement* $\to$ Analyser des informations fourni par les processus sur toutes les demandes de ressources
- Option 2 - Autoriser le système à entrer dans un état de blocage, puis *récupérer*
- Option 3 - La méthode de l'autruche
  - Permettre des interblocages
  - Ne même pas essayer de les détecter
  - Méthode la plus populaire

** Prévention

Exploration des conditions que peuvent être prévenues

- *Exclusion mutuelle* - Certaines ressources sont partageables, mais ce n'est pas le cas tous le temps
  - Impossible à éviter en général

- *"Hold & wait"* - Doit garantir que chaque fois qu'un processus demande une ressource, il ne tient aucune autre ressource
  - Solution 1 - Exiger que le processus demande et reçoive toutes ses ressources avant de commencer l'exécution
  - Solution 2 - Autoriser le processus à demander des ressources uniquement lorsque le processus n'a aucune ressource en possession
    - Il doit libérer ses ressources actuelles avant de les demander à nouveau
  - Désavantages des 2 solutions
    - Moins d'utilisation des ressources
    - Famine possible (toujours en attente)

- *Pas de préemption*
  - Si un processus qui tient des ressources demande une autre ressource qui n'est pas disponible, toutes ses ressources tenus sont libérées
  - Les ressources préemptées sont ajoutées à la liste des ressources pour lesquelles le processus est en attente
  - Le processus ne sera redémarré que lorsqu'il pourra retrouver ses anciennes ressources ainsi que les nouvelles qu'il demande

- *Circular wait*
  - Imposer un ordre total entre tous les types de ressources
  - Exiger que chaque processus demande des ressources dans un ordre croissant d'énumération, ou libère des ressources d'ordre supérieur ou égal

$F : R \mapsto \mathbb N$
$R_j \textrm{ après } R_i \Implies F(R_j) > F(R_i)$

#+begin_src c

  // Exemple d'interblocage
  // F(first_mutex) = 1
  // F(second_mutex) = 5

  /* Thread one runs in this function */
  void *do_work_one(void *param) {
      pthread_mutex_lock(&first_mutex);
      pthread_mutex_lock(&second_mutex);

      // Do some work

      pthread_mutex_unlock(&second_mutex);
      pthread_mutex_unlock(&first_mutex);
      pthread_exit(0);
  }

  /* Thread two runs in this function */
  void *do_work_two(void *param) { // Thread 2 viole la condition d'ordre imposée
      pthread_mutex_lock(&second_mutex);
      pthread_mutex_lock(&first_mutex);

      // Do some work

      pthread_mutex_unlock(&first_mutex);
      pthread_mutex_unlock(&second_mutex);
      pthread_exit(0);
  }

#+end_src

#+begin_src c

  // Un autre exemple d'interblocage possible
  void transaction(Account from, Account to, double amount) {
      mutex lock1, lock2;
      lock1 = get_lock(from);
      lock2 = get_lock(to);

      acquire(lock1);
      acquire(lock2);
      withdraw(from, amount);
      deposit(to, amount);
      release(lock2);
      release(lock1);
  }

  // thread1 - transaction(checking, savings, 25)
  // thread2 - transaction(savings, checking, 40)

#+end_src

** Évitement

Besoin d'information sur le futur
- Ex.: Chaque thread annonce son usage maximale de ressources
- En cours d'exécution, le système vérifie l'état d'allocation de ressources pour garantir qu'on ne tombera pas dans un cycle
- L'état d'allocation de ressources est la quantité de ressources allouées et disponibles, ainsi que les usages maximaux annoncés

*** État sûr

*Allocation* $\to$ Le système doit décider si une allocation laisse le système dans un état sûr (safe)
*L’état est sûr (safe)* $\to$ S’il existe une séquence d’exécution $\langle P_1, P_2, \dots, P_n \rangle$ de tous les processus (threads) telle que pour chaque $P_i$, les ressources dont il a besoin seront disponible quand tous les $P_j, j < i$ auront terminé leur exécution
- Quand $P_i$ termine, $P_{i+1}$ peut obtenir ses ressources nécessaires

État sûr (safe) $\to$ Pas d'interblocage
État pas sûr (unsafe) $\to$ Possibilité d'interblocage
- Interblocage $\to$ État pas sûr

Évitement $\equiv$ Garantir que le système est toujours dans un état sûr

**** Exemple d'analyse

Exemple avec état sûr

Ressources - 12 instances

| Processus | Maximum | Actuel |
|-----------+---------+--------|
| P0        |      10 |      5 |
| P1        |       4 |      2 |
| P2        |       9 |      2 |


| Exécution  | P0    | P1   | P2   | Total des ressources tenues |
|------------+-------+------+------+-----------------------------|
| Debut      | 5/10  | 2/4  | 2/9  | 5 + 2 + 2 = 9               |
| P1 exécute | 5/10  | 4/4  | 2/9  | 9 + 2 = 11 -> 7             |
| P0 exécute | 10/10 | fini | 2/9  | 7 + 5 = 12 -> 2             |
| P2 exécute | fini  | fini | 9/9  | 2 + 7 = 9 -> 0              |
| Fin        | fini  | fini | fini | 0                           |

- Exécution est possible - Donc état sûr


Exemple avec état pas sûr

Ressources - 12 instances

| Processus | Maximum | Actuel |
|-----------+---------+--------|
| P0        |      10 |      5 |
| P1        |       4 |      2 |
| P2        |       9 |      3 |


| Exécution  | P0    | P1   | P2  | Total des ressources tenues |
|------------+-------+------+-----+-----------------------------|
| Debut      | 5/10  | 2/4  | 3/9 | 5 + 2 + 3 = 10              |
| P1 exécute | 5/10  | 4/4  | 3/9 | 10 + 2 = 12 -> 8            |
| P0 exécute | 10/10 | fini | 3/9 | 13 > 12                     |
| P2 exécute | 5/10  | fini | 9/9 | 14 > 12                     |

- Exécution n'est pas possible - Donc état pas sûr

*** Algorithme d'évitement

- Ressources uniques
  - Utiliser un algorithme basé sur le *graphe d'allocation de ressources*
- Pour des ressources multiples
  - Utiliser *l'algorithme du banquier*

**** Évitement basé sur le graphe d'allocation

Deux types d'arcs $P_i \to R_j$
- Normaux pour les requêtes en attente
- Futurs pour les requêtes qui pourraient encore arriver (/claim edges/)

- Un *arc futur* peut être convertir en un *arc requête*
- Un *arc requête* peut être converti en un *arc allocation* quand le ressource est alloué au processus
Il est nécessaire de connaitre les arcs futurs dès le départ


Supposons que le processus $P_i$ demande une ressource $R_j$
- Une ressource est allouée seulement si cela ne crée pas de cycle (y compris les arcs futurs)
[[/home/phil-gab99/Documents/Notes/IFT-2245/20220216172723-gestion_interblocage.org_20220216_181112_z9IGzA.png]]

**** Algorithme du banquier

- Plusieurs instances d'un type de ressources
- Chaque processus doit a priori déclarer le nombre maximum d'instances de chaque type de ressource
- Lorsqu'un processus demande une ressource, il faudra peut-être attendre
- Quand un processus obtient toutes ses ressources, il doit les renvoyer dans un temps fini

***** Données

$n$ - Nombre de processus
$m$ - Nombre de types de ressources

- ~Available[j]~ - Quantité de ressource ~j~ disponible, vecteur de longueur $m$
- ~Max[i, j]~ - Quantité maximum de ressource ~j~ utilisé par processus ~i~, matrice $n \times m$
- ~Allocated[i, j]~ - Quantité de ressource ~j~ allouée à processus ~i~, matrice $n \times m$
- ~Needed[i, j]~ - Quantité de ressource ~j~ dont processus ~i~ pourrait encore avoir besoin pour terminer son exécution - matrice $n \times m$

  ~Needed[i, j] = Max[i, j] - Allocated[i, j]~

***** État sûr

+ Étape 1
  ~Initialize~

  ~Work = Available~
  ~Finish[i] = false for i = 0, 1, ..., n - 1~

+ Étape 2
  Trouver un ~i~ pour que:

  1) ~Finish[i] == false~
  2) ~Needed[i, j] <= Work[j] for all j~
   
  Si aucun ~i~ procéder a 4

+ Étape 3
  ~Work[j] += Allocated[i, j] for all j~
  ~Finish[i] = true~

  Retour à 2

+ Étape 4
  ~if Finish[i] for all i~ Système dans un état sûr
  ~else~ Système pas sûr

***** Allouer des ressources

~Requested[i, j]~ - Requête de processus ~Pi~ pour ressource j
Si ~Requested[i, j] == k~, ~Pi~ veut ~k~ instances de la ressource ~j~

~Pi~ fait sa requête
1. Si ~Requested[i, j] > Needed[i, j] for any j~ - Erreur!
2. Si ~Requested[i, j] > Available[j] for any j~ - Doit attendre
3. Sinon, essaye d'alloué les ressources à ~Pi~ après avoir calculer un nouvel état hypothétique
   ~Available[j] -= Requested[i, j] for all j~
   ~Allocated[i, j] += Requested[i, j] for all j~
   ~Needed[i, j] -= Requested[i, j] for all j~
4. Tester la sécurité en utilisant la procédure pour vérifier si état sûr
   État sûr $\to$ Allouer les ressources
   État pas sûr $\to$ ~Pi~ doit attendre

***** Exemple d'algorithme du banquier

[[/home/phil-gab99/Documents/Notes/IFT-2245/20220216172723-gestion_interblocage.org_20220216_183124_TnVZfn.png]]
