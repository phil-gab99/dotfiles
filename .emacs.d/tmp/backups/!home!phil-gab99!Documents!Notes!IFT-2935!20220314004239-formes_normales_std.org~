:PROPERTIES:
:ID:       0f535555-32a2-4e86-a8f8-c9cf4b56bf41
:END:
#+title: ift2935-formes-normales-std
#+STARTUP: latexpreview inlineimages
#+date: [2022-03-14 Mon 00:42]

* Formes normales standard

Pour Codd (concepteur) $\to$ Normaliser une relation c'est de lui appliquer une ou des décompositions afin d'éliminer les problèmes de redondance interne
Pour d'autres dont Delobel $\to$ Les dépendances fonctionnelles sont une spécification de contraintes d'intégrité et l'objectif est de décomposer en relations qui implantent ces contraintes grâce aux déclarations de clés
C'est à l'aide de la notion de *clé* et de *dépendance* qu'on définit les formes normales d'un schéma relationnel
Il existe 7 formes normales - 1NF, 2NF, 3NF, BCNF(Boyce-Codd), 4NF, ...
- Les conditions sont de plus en plus restrictives (de gauche à droite)
- Les décompositions 1NF, 2NF, 3NF et BCNF se font sans perte d'information
- Les décompositions 1NF, 2NF et 3NF préservent les dépendances fonctionnelles
- La décomposition BCNF peut ne pas préserver des dépendances fonctionnelles

** Première forme normale - 1NF

Une relation est en *première forme normale* (1NF) si et seulement si tout attribut contient une *valeur atomique*
- La valeur d'un attribut ne peut pas être une liste ou un tableau
- Exemple, la table ~livre~ ci-dessous n'est pas en 1NF (colonne auteurs):

  | Cote           | Titre                            | Auteurs                       | Annee |
  |----------------+----------------------------------+-------------------------------+-------|
  | QA 76.9 D3 E44 | Fundamentals of database systems | _Elmasri, Ramez; Navathe, Sham_ |  2016 |

- Un champ ne peut pas non plus être une liste de résidences secondaires, de numéros de téléphone, de prénoms, etc..

*** Première solution

On se donne autant d'attributs que le nombre maximum de valeurs de l'attribut multi-valué (stockage horizontal)

  | Cote           | Titre                               | Auteur1        | Auteur 2      | Annee |
  |----------------+-------------------------------------+----------------+---------------+-------|
  | QA 76.9 D3 E44 | Fundamentals of database systems    | Elmasri, Ramez | Navathe, Sham |  2016 |
  | QA 76.9 D3 D37 | An introduction to database systems | Date, C. J     | NULL          |  2004 |

- Ici on a admis qu'il y a au maximum deux auteurs, ça n'irait pas avec un livre avec trois auteurs - Quel est le maximum?

*** Deuxième solution

On décompose la relation initiale en deux relations

1. La projection de la relation initiale sur les autres attributs
2. La relation ayant pour attributs la clé de la relation initiale et l'attribut "multi-valué"

Les valeurs des attriubts sont mises chacune danns un tuple (stockage vertical)

~livre~
| Cote           | Titre                               | Annee |
|----------------+-------------------------------------+-------|
| QA 76.9 D3 E44 | Fundamentals of database systems    |  2016 |
| QA 76.9 D3 D37 | An introduction to database systems |  2004 |

~auteur~
| Cote           | Auteur         |
|----------------+----------------|
| QA 76.9 D3 E44 | Elmasri, Ramez |
| QA 76.9 D3 E44 | Navathe, Sham  |
| QA 76.9 D3 D37 | Date, C. J     |

** Deuxième forme normale - 2NF

Une relation est en *deuxième forme normale* (2NF) si et seulement si
1. Elle est en *1NF*
2. Tout *attribut non clé* (i.e. n'appartenant pas à une clé) n'est pas en dépendance fonctionnelle d'une partie de clé (candidate)

Pour ne pas être en 2NF, il faut:
- Une clé (candidate) $X$ composée
- Un sous-ensemble propre $Y \subsetneq X$ et un attribut non clé $A$ tels que $Y \to \{A\} \in \mathcal F^+$

*** Exemple de Date

On a une table avec attributs ~SNUM, SNAME, SCITY, STATUS, PNUM, PNAME, PCOLOR, PWEIGHT, PCITY~ et ~QTY~
- ~SNUM~ est le numéro d'un fournisseur de nom ~SNAME~, situé dans ~SCITY~ et coté ~STATUS~
- ~PNUM~ est le numéro d'un produit de nom ~PNAME~, couleur ~PCOLOR~, poids ~PWEIGHT~ situé dans ~PCITY~
- ~QTY~ est la quantité du produit ~PNUM~ commandée à ~SNUM~

On a les dépendances fonctionnelles:
- ~SNUM -> SNAME, SCITY, STATUS~
- ~PNUM -> PNAME, PCOLOR, PWEIGHT, PCITY~
- ~SNUM, PNUM -> QTY~

~SNUM, PNUM~ est une clé de cette relation - il n'y en a pas d'autres mais c'est ici sans importance pour la définition

| SNUM | SNAME | SCITY  | STATUS | PNUM | PNAME | PCOLOR | PWEIGHT | PCITY  | QTY |
|------+-------+--------+--------+------+-------+--------+---------+--------+-----|
|    1 | Smith | London |     20 |    1 | Nut   | Red    |    12.0 | London | 300 |
|    1 | Smith | London |     20 |    2 | Bolt  | Green  |    17.0 | Paris  | 200 |
|    1 | Smith | London |     20 |    3 | Screw | Blue   |    17.0 | Oslo   | 400 |
|    1 | Smith | London |     20 |    4 | Screw | Red    |    14.0 | London | 200 |
|    1 | Smith | London |     20 |    5 | Cam   | Blue   |    12.0 | Paris  | 100 |
|    1 | Smith | London |     20 |    6 | Cog   | Red    |    19.0 | London | 100 |
|    2 | Jones | Paris  |     10 |    1 | Nut   | Red    |    12.0 | London | 300 |
|    2 | Jones | Paris  |     10 |    2 | Bolt  | Green  |    17.0 | Paris  | 400 |
|    3 | Blake | Paris  |     30 |    2 | Bolt  | Green  |    17.0 | Paris  | 200 |
|    4 | Clark | London |     20 |    2 | Bolt  | Green  |    17.0 | Paris  | 200 |
|    4 | Clark | London |     20 |    4 | Screw | Red    |    14.0 | London | 300 |
|    4 | Clark | London |     20 |    5 | Cam   | Blue   |    12.0 | Paris  | 400 |

- Cette relation est bien en 1NF - Aucune colonne n'est multivaluée
- Elle n'est pas 2NF car par exemple ~SNUM -> SNAME~ - L'attribut ~SNAME~ est non clé et il dépend d'une partie de la clé ~SNUM, PNUM~

*** Solution - 1NF à 2NF

1. On regroupe dans une relation les attributs dépendant de la totalité de la clé et on conserve cette clé pour cette table
2. On regroupe dans une autre relation les attributs dépendants d'une partie de la clé et on en fait la clé (primaire) de la nouvelle relation


- Dans l'exemple des fournisseurs, uniquement l'attribut ~QTY~ dépend de toute la clé - On garde donc la projection sur les attributs ~SNUM, PNUM, QTY~ (première table)
- On garde la projection sur ~SNUM^+ = {SNUM, SNAME, SCITY, STATUS}~ qui dépend fonctionnellement de ~SNUM~ (partie de la clé de la relation initiale) et dont ~SNUM~ devient la clé (deuxième table)
- On garde la projection sur ~PNUM^+ = {PNUM, PNAME, PCOLOR, PWEIGHT, PCITY}~ qui dépend fonctionnellement de ~PNUM~ (partie de la clé de la relation initiale) et dont ~PNUM~ devient la clé (troisième table)

**** Exemple

Dans l'exemple ~COM(Ncli, Nom, Adresse, Ncom, Date, Npro, Qte, PrixUnit)~, l'ensemble de dépendances était:
~Ncli -> Nom~
~Ncli -> Adresse~
~Ncom -> Ncli~
~Ncom -> Date~
~Ncom, Npro -> Qte~
~Npro -> PrixUnit~
- La clé unique est ~Ncom, Npro~ (i.e. ~{Ncom, Npro}^+~ est l'ensemble de tous les attributs)
  - On garde la projection de ~COM~ sur ~{_Ncom_, _Npro_, Qte}~
  - On garde la projection sur ~{_Npro_, PrixUnit} = {Npro}^+~
  - On garde la projection sur ~{Ncom, Date, Ncli, Nom, Adresse} = {Ncom}^+~
    - Note que cette dernière projetion est bien 2NF:
      - ~Ncom~ est bien une clé - Les dépendances sont les suivantes et ~Ncom^+~ donne bien tous les attributs de cette relation
        ~Ncom -> Date~
        ~Ncom -> Ncli~
        ~Ncli -> Nom~
        ~Ncli -> Adresse~
      - C'est la seule clé - ~Ncom~ n'est pas à droite de la flèche de dépendance
      - Aucun attribut ne peut dépendre d'une partie de clé car l'unique clé n'a qu'un attribut

        | Ncom |       Date | Ncli | Nom      | Adresse     |
        |------+------------+------+----------+-------------|
        |    1 | 2017-05-02 |    1 | John     | South-Mount |
        |    2 | 2017-07-03 |    1 | John     | South-Mount |
        |    3 | 2017-08-05 |    1 | John     | South-Mount |
        |    4 | 2017-08-06 |    2 | Alfred   | Avantmont   |
        |    5 | 2017-08-07 |    3 | Tal      | Avantmont   |
        |    6 | 2017-08-06 |    2 | Alfred   | Avantmont   |
        |    7 | 2017-08-05 |    3 | Tal      | Avantmont   |
        |    8 | 2017-07-24 |    4 | Dalibert | Pise        |
        |    9 | 2017-07-25 |    3 | Tal      | Avantmont   |

      - Cependant, il y a encore de la redondance
      - Si le client 1, John, avertit qu'il a changé d'adresse, il va falloir changer plusieurs occurrences dans la table
      - 2NF n'est donc *pas suffisant*

Précédemment, la table ~COM~ a été différemment décomposé comme suit:
~produit(_Npro_, PrixUnit)~
~client(_Ncli_, Nom, Adresse)~
~commande(_Ncom_, _Npro_, Qte, Ncli, Date)~
- On a $\mathcal F_{\mathtt{commande}} =$ {~Ncom, Npro -> Qte, Ncom -> Ncli, Ncom -> Date}~
- Cette relation n'est 2NF, car ~Ncli~ et ~Date~ dépendent d'une partie de clé
  - Afin de normaliser, il est nécessaire de projeter sur ~{_Ncom_, _Npro_, Qte}~
  - Puis de garder la projection sur ~{_Ncom_, Ncli, Date}~
  - On se retrouve ainsi avec une décomposition de ~COM~ en quatres relations

** Troisième forme normale - 3NF

Soit $A$ un attribut et $X$ un ensemble d'attributs - La dépendance $X \to \{A\}$ est dite *transitive* s'il existeun ensemble d'attributs $Y$ tel que $X \to Y \to \{A\}$ avec $A \notin Y, Y \nsubseteq X, Y \not \to X$
- Si $X \to \{A\}$ n'est pas *transitive*, on dit que $A$ *dépend directement* de $X$

Une relation est en troisième forme normale (3NF) si et seulement si:
1. Elle est en *2NF*
2. Chaque attribut non clé est *directement dépendant* des clés (Codd)

Une définition équivalente due à Zaniolo - Une relation est 3NF si et seulement si:
1. Elle est en *1NF*
2. Pour toute $X \to \{A\} \in \mathcal F$, l'une des conditions suivantes est satisfaite
   + $A \in X$ (i.e. $X \to \{A\}$ est triviale)
   + $X$ est une superclé (contient une clé (candidate))
   + $A$ est un attribut clé (i.e. figure dans une clé (candidate) de $R$)
Cette définition implique 2NF

*** Exemple

Lors du passage de 1NF à 2NF à partir de ~COM(Ncli, Nom, Adresse, Ncom, Date, Npro, Qte, PrixUnit)~, on a projeté sur ~{_Ncom_, _Npro_, Qte}~, ~{Npro, PrixUnit}~ et ~{_Ncom_, Date, Ncli, Nom, Adresse}~
- On pouvait remarquer de la redondance présente dans la dernière relation
- Cette relation n'est pas 3NF - En effet, les dépendances fonctionnelles sont ~Ncom -> Ncli~, ~Ncom -> Date~, ~Ncli -> Nom~, ~Ncli -> Adresse~
  - On retrouve par exemple cette *dépendance transitive* ~Ncom -> Ncli -> Nom~ pour ~Nom~ qui est non clé
  - Par la définition de Zaniolo, on a ~Ncli -> Nom~ qui ne satisfait aucune de ces conditions:
    - La dépendance n'est pas triviale
    - ~Ncli~ n'est pas une superclé
    - ~Nom~ n'est pas attribut clé

Notons ~COM[Ncom, Date, Ncli, Nom, Adresse]~ la projection qui n'est pas 3NF
- Les dépendances fonctionnelles sont ~Ncom -> Ncli~, ~Ncom -> Date~, ~Ncli -> Nom~, ~Ncli -> Adresse~
- On utilise le *théorème de Heath* avec les DF à partir de ou des attributs non clé dont dépendent transitivement d'autres attributs
  - Dans l'exemple on a
    - ~Ncli -> Nom, Adresse~
    - Déterminant: ~Ncli~; Déterminé: ~Nom, Adresse~; Résidu: ~Ncom, Date~
    - On a donc comme décomposition les projections:
      - ~COM[Nom, _Ncli_, Adresse]~ - Déterminant et déterminé
      - ~COM[Ncli, _Ncom_, Date]~ - Déterminant et résidu
    - On retrouve la décomposition en 4 relations mentionnées précédemment

*** Algorithme de Bernstein

Entrée: Un schéma $R$ (arbitraire) et un ensemble $\mathcal F$ de DF qui soit 1NF
Sortie: Projections donnant des schémas $R$, en 3NF pour tout $i$ sans perte d'information et préservant les dépendances

1. Intiialiser $P$ (ensemble de projection) à l'ensemble vide (et $i = 1$)
2. Fixer $\mathcal G$ une [[id:cb553b56-04d6-42eb-abd0-e76e85e9ba32][couverture minimale]] de $\mathcal F$
3. Pour chaque $X$ distinct d'une partie gauche d'une DF de $\mathcal G$
   3.1 Faire la réunion $Y$ de tous les $\{A\}$ tels que $X \to \{A\} \in \mathcal G$
   3.2 Ajouter à $P$ la projection de $R$ sur $X, Y$ (donne $R_i(\underline{X}, Y) = \pi_{XY}(R)$, avec clé primaire $X$)
   3.3 $i++$
4. Si aucune des projections dans $P$ ne contient une clé candidate de $R$, ajouter à $P$ la projetion de $R$ sur une clé candidate, ($R_i(K) = \pi_K(R)$ pour $K$ clé candidate)

$R$ est alors la jointure naturelle des projections obtenues - La décomposition est sans perte

**** Exemple

Pour l'exemple ~COM(Ncli, Nom, Adresse, Ncom, Date, Npro, Qte, PrixUnit)~, on obtient:

\begin{tabular}{| l | l | l |}
\hline
Couverture minimale & Factorisation & Projections \\
\hline
\hline
Ncli $\to$ Nom; Ncli $\to$ Adresse; & Ncli $\to$ Nom, Adresse & $R_1$ (\underline{Ncli}, Nom, Adresse) \\
Ncom $\to$ Ncli; Ncom $\to$ Date; & Ncom $\to$ Ncli, Date & $R_2$ (\underline{Ncom}, Ncli, Date) \\
Ncom, Npro $\to$ Qte; & Ncom, Npro $\to$ Qte & $R_3$ (\underline{Ncom}, \underline{Npro}, Qte) \\
Npro $\to$ PrixUnit; & Npro $\to$ PrixUnit & $R_4$ (\underline{Npro}, PrixUnit) \\
\hline
\end{tabular}

- La clé ~{Ncom, Npro}~ est présente dans $R_3$ - Donc l'étape 4 ne s'applique pas
- Le choix de la clé (qui sera primaire en SQL) dans chaque relation implante les dépendances fonctionnelles correspondantes de la couverture minimale
- Toutes les dépendances de $\mathcal F$ sont ainsi satisfaites

**** Exemple

Soit $R(A, B, C, D, E, F, G, H, I)$ avec $\mathcal F = \{A \to B; \quad A \to C; \quad C, D \to E; \quad B \to D; \quad F \to G\}$
- $\mathcal F$ est déjà une couverture minimale
  - Toutes les dépendances sont élémentaires - Aucune dépendance triviale, $C^+ \neq (CD)^+$ et $D^+ \neq (CD)^+$
  - Aucune dépendance ne peut être supprimée sans enlever des dépejndances de $\mathcal F^+$
- On obtient les groupements $A \to B, C; \quad C, D \to E; \quad B \to D; \quad F \to G$
- Les projections correspondantes sont $R_1(\underline A, B, C), R_2(\underline{C, D}, E), R_3(\underline B, D), R_4(\underline F, G)$
- L'unique clé $\{A, F, H, I\}$ ne figure dans aucune des projections - On ajoute $R_5(\underline{A, F, H, I})$
  - $A^+ = ABCDE; F^+ = FG; (AF)^+ = ABCDEFG; AFHI$ est la seule clé candidate

En procédant dans le bon ordre, on arrive à retrouver cette même décomposition par application successive du théorème de Heath

\begin{tabular}{| l | l | l | l |}
\hline
DF & $R(\underline{\mathit{detant}}, \mathit{detne})$ & $R'(\mathit{detant}, \mathit{residu})$ & Dépendances sur $R'$ \\
\hline
\hline
& & $R(A, B, C, D, E, F, G, H, I)$ & $A \to BC; \quad CD \to E; \quad B \to D; \quad F \to G; \\
$CD \to E$ & $R_2(\underline{C, D}, E)$ & $R_2'(A, B, C, D, F, G, H, I)$ & $A \to BC; \quad B \to D; \quad F \to G; \\
$B \to D$ & $R_2(\underline B, D)$ & $R_3'(A, B, C, F, G, H, I)$ & $A \to BC; \quad F \to G$ \\
$A \to BC$ & $R_1(\underline A, B, C)$ & $R_1'(A, F, G, H, I) & $F \to G$ \\
$F \to G$ & $R_4(\underline F, G)$ & $R_4'(A, F, H, I)$ & \\
\hline
\end{tabular}

- Il reste alors comme résidu $R_5(A, F, H, I) = R_4'(A, F, H, I)$
- Par le théorème de Heath, il suit que
  $R = R_2 \Join R_2' = R_2 \Join R_3 \Join R_3' = R_2 \Join R_3 \Join R_1 \Join R_1' = R_2 \Join R_3 \Join R_1 \Join R_4 \Join R_5$
- Note que les jointures naturelles sont associatives et commutatives

** Forme normale de Boyce-Codd - BCNF

La définition de 3NF (initialement donnée par Codd) crée problème si la relation possède deux cleś candidates composées qui se chevauchent (ont un attribut en commun, qui est rare) - sinon 3NF et BCNF sont équivalentes

Définition $\Rightarrow$ Un schéma relationnel $R(U)$ avec ensemble $\mathcal F$ de DF est en forme BCNF si et seulement si pour chaque dépendance élémentaire $X \to A$ dans $\mathcal F^+$, $X$ est une clé (candidate)

Définition (Zaniolo) $\Rightarrow$ Un schéma relaionnel $R(U)$ avec ensemble $\mathcal F$ de DF est en forme BCNF si et seulement si pour tout $X \to A \in \mathcal F$, soit $A \in X$ ou $X$ est une super-clé

Toute relation $R$ peut être décomposée sans perte d'information en relations BCNF (elle en sera la jointure naturelle) mais il peut arriver que des dépendances fonctionnelles soient perdues

*** Exemple

Soit $R(A, B, C, D)$ avec $\mathcal F = \{AB \to C; \quad AB \to D; \quad D \to B\}$
- $(AB)^+ = ABCD$, $(AD)^+ = ABCD$ - On a deux clés candidates qui se chevauchent
- $A^+ = A, B^+ = B, C^+ = C, D^+ = DB$
- Les dépendances fonctionnelles élémentaires dans $\mathcal F^+$ sont $AB \to C, AB \to D, AD \to C, D \to B$
- $R$ est 3NF (Zaniolo)
  - $B$ en partie droite est attribut clé et la DF satisfait la condition 3 - Les parties gauches des autres DF sont des super-clés (en fait des clés) donc satisfont la condition 2
  - $R$ n'est pas BCNF - La DF $D \to B$ ne satisfait ni la condition 1 ($D \to B$ n'est pas triviale) ni la condition 2 ($D$ n'est pas superclé)

*** Algorithme de Boyce-Codd

Entrée: Un schéma $R(U, \mathcal F)$, $U$ ensemble d'attributs, $\mathcal F$ ensembles de dépendances fonctionnelles
Sortie: Une décomposition $D = \{R_1(U_1, \mathcal F_1), \dots, R_n(U_n, \mathcal F_n)\}$ sans perte d'information avec $R_i(U_i, \mathcal F_i)$ BCNF pour tout i (mais perte possible de dépendances)

1. Initialiser $D$ à $\{R(U, \mathcal F)\}$
2. Tant qu'il y a $R'(U', \mathcal F') \in D$ qui n'est pas BCNF
   2.1 Trouver une dépendance non-triviale $X \to Y$ dans $\mathcal F'$ t.q. $X \neq X^+$ et $X^+ \neq U'$
   2.2 Poser $U_1' = X^+, U_2' = X \cup (U' - X^+), \mathcal F_1'$ les dépendances sur $U_1'$, $\mathcal F_2'$ celles sur $U_2'$
   2.3 Remplacer $R'(U')$ par ses projections sur $U_1'$ et $U_2'$ - $R_1'(U_1', \mathcal F_1')$ et $R_2'(U_2', \mathcal F_2')$
   - $R' = R_1' \Join R_2'$ par Heath avec $X$ déterminant, $X^+ - X$ déterminé et $U' - X^+$ résidu

Le calcul de $\mathcal F_1'$ et $\mathcal F_2'$ à partir de $\mathcal F'$ doit se faire avec l'algorithme de *projection des dépendances*
- Pas seulement avec Boyce-Codd, mais aussi avec les passages de 1NF à 2NF à 3NF
- L'algorithme de Bernstein permet d'éviter ces calculs mais demande celui d'une couverture minimale de $\mathcal F$

**** Exemple

Soit $R(A, B, C, D, E)$ avec $\mathcal F = \{A \to B; \quad BC \to D\}$, $U = \{A, B, C, D, E\}$

- $D = \{R(U, \mathcal F)\}$
- $\{A\} \neq \{A\}^+ = \{A, B\} \neq U$
  - $U_1 = \{A, B\}, \quad U_2 = \{A, C, D, E\}$
  - Pour $R_1(U_1), \mathcal F_1 = \{A \to B\}$ ($R_1$ est BCNF)
- $D = \{R_1(U_1, \mathcal F_1), R_2 (U_2, \mathcal F_2)\}$
  - Quel est $\mathcal F_2$ - Il faut ici calculer une projection
    - $\{A, C\}^+ \cap U_2 = \{A, B, C, D\} \cap U_2 = \{A, C, D\}$ et donc $AC \to D$ est dans $\mathcal F_2$
    - Aucune autre $X \subseteq U_2$ n'est tel que $X^+ \cap U_2 \neq X$ et donc $\mathcal F_2 = \{AC \to D\}$

Reprenons avec toutes les dépendances élémentaires de $\mathcal F^+$ pour éviter de calculer à chaque fois les projections

Soit $R(A, B, C, D, E)$ avec $\mathcal F = \{A \to B; \quad BC \to D\}$, $U = \{A, B, C, D, E\}$
Toutes les DF élémentaires de $\mathcal F^+$ figurent dans $\{A \to B; \quad BC \to D; \quad AC \to D\}$

- $D = \{R(U, \mathcal F)\}$
- $\{A\} \neq \{A\}^+ = \{A, B\} \neq U$
  - $U_1 = \{A, B\}, \quad U_2 = \{A, C, D, E\}$
  - Pour $R_1(U_1), \mathcal F_1 = \{A \to B\}$ ($R_1$ est BCNF)
  - Pour $R_2(U_2), \mathcal F_2 = \{AC \to D\}$
- $D = \{R_1(U_1, \mathcal F_1), R_2 (U_2, \mathcal F_2)\}$ - On recommence avec $R_2(U_2, \mathcal F_2)$
  - $\{A, C\}^+ = \{A, C, D\} \neq U_2$
  - $U_{21} = \{A, C, D\}, U_{22} = \{A, C, E\}$
  - $\mathcal F_{21} = \{AC \to D\}; \mathcal F_{22} = \emptyset$
- $D = \Big \{R_1(A, B, \{A \to B\}), R_{21}(A, C, D, \{AC \to D\}), R_{22}(A, C, E, \emptyset) \Big \}$
- C'est la décomposition finale - On a perdu $BC \to D$ car $D \notin \{B, C\}^+$ par rapport à $\mathcal F_1 \cup \mathcal F_{21} \cup \mathcal F_{22} = \{A \to B; \quad AC \to D\}$

*** Projection des dépendances fonctionnelles

Entrée: Un schéma $R(U, \mathcal F)$ et $U_1 \subset U$
Sortie: Les dépendances $F_1$ induites sur $R_1(U_1) = \pi_{U_1}(R)$

Si $\mathcal F$ contient toutes les dépendances élémentaires de $\mathcal F^+$, il suffit de prendre pour $\mathcal F_1$ l'ensemble de celles qui ne font intervenir que des attributs dans $U_1$
Sinon:
1. $\mathcal F_1 = \emptyset$ (initialisation)
2. Pour chaque $X \subseteq U_1$
   2.1 Calculer $X^+ (par rapport à $\mathcal F$)
   2.2 Ajouter à $\mathcal F_1$ toutes les $X \to {A}$ t.q. $A \in (X^+ - X) \cap U_1$
   - Optionnel: Et t.q. on n'a pas déjà $Y \to \{A\} \in \mathcal F_1$ avec $Y \subset X$
3. Optionnel: Enlever de $\mathcal F_1$ les dépendances redondantes
4. Retourner $\mathcal F_1$

**** Exemple

Soit 
