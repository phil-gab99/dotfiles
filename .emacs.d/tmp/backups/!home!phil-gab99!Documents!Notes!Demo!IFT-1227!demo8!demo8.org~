#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline \n:t
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: IFT-1227 Demo 7
#+date: <2022-03-17 Thu>
#+author: Philippe Gabriel
#+email: philippe.gabriel.1@umontreal.ca
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.0.01 (Org mode 9.5.2)
#+cite_export:

* VHDL

** Intra A12 - Q3

*** Question 3 a)

Coder en VHDL le circuit suivant:

[[/home/phil-gab99/Documents/Notes/Demo/IFT-1227/intra/intra.org_20220317_021120_aUEcgs.png]]

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity q3a is
  -- TODO
  end q3a;

  architecture q3asynth of q3a is
  begin
  -- TODO
  end q3asynth;

#+end_src

**** Solution

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity q3a is
    port(A3, A2, A1, A0: in STD_LOGIC
         Y3, Y2, Y1, Y0: out STD_LOGIC);
  end;

  architecture synth of q3a is
  begin
    Y3 <= A3;
    Y2 <= (not A3) and A2;
    Y1 <= (not A3) and (not A2) and A1;
    Y0 <= (not A3) and (not A2) and (not A1) and A0;
  end;

#+end_src

*** Question 3 b)

Écriver le module VHDL d'un décodeur 2:4 appelé ~dec2~ avec les entrées ~d0, d1~ et les sorties ~y0, y1, y2, y3~

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity dec2 is
  -- TODO
  end dec2;

  architecture synth of dec2 is
  begin
  -- TODO
  end synth;

#+end_src

**** Solution

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity dec2 is
    port(d0, d1: in STD_LOGIC
         y0, y1, y2, y3: out STD_LOGIC);
  end;

  architecture synth of dec2 is
    signal d: STD_LOGIC_VECTOR(1 downto 0);
  begin
    d <= d0 & d1;
  -- A change in value on one or more of these signals, causes the process to be
  -- activated
    process(d)
      variable y: STD_LOGIC_VECTOR(3 downto 0)
    begin
      case d is
        when "00" => y <= "0001"
        when "01" => y <= "0010"
        when "10" => y <= "0100"
        when "11" => y <= "1000"
      end case;
      y0 <= y(0);
      y1 <= y(1);
      y2 <= y(2);
      y3 <= y(3);
    end process;
  end;

#+end_src

*** Question 3 c)

Écrivez le module VHDL *structurel* du circuit présenté plus bas

[[/home/phil-gab99/Documents/Notes/Demo/IFT-1227/intra/intra.org_20220317_022921_fWS4ga.png]]

Structurel $\to$ Décomposer en *composantes*

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity q3c is
  -- TODO
  end q3c;

  architecture struct of q3c is
  begin
  -- TODO
  end struct;

#+end_src

**** Solution

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity func is
    port(A, B: in STD_LOGIC
         Y: out STD_LOGIC);
  end;

  architecture struct of func is
    -- Déclarations
    component dec2 -- Fait référence à l'entité dec2 définie au b)
      port(d0, d1: in STD_LOGIC
           y0, y1, y2, y3: out STD_LOGIC);
    end component;

    component or2 -- Devrait avoir un fichier avec entité or2 pour l'utiliser
      port(a1, a2: in STD_LOGIC
           y: out STD_LOGIC);
    end component;

    signal y_dec: STD_LOGIC_VECTOR(3 downto 1);
  begin
    dec2_q3c: dec2 port map(A, B, y_dec(3), y_dec(2), y_dec(1), y_dec(0));
    or2_q3c: or2 port map(y_dec(0), y_dec(3), Y);
  -- Ou tout simplement: Y <= y_dec(3) or y_dec(0);
  end;

#+end_src

** Intra A12 - Q4

*** Question 4 b)

Implémenter la machine [Moore/Mealy?] suivante en VHDL

[[/home/phil-gab99/Documents/Notes/Demo/IFT-1227/intra/intra.org_20220317_024639_5tnUPh.png]]

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all

  entity [mealy/moore?] is
  -- TODO
  end;

  architecture synth of [mealy/moore] is
  begin
  -- TODO
  end;


#+end_src

**** Solution

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity mealy is
    port(clk, reset: in STD_LOGIC;
         X: in STD_LOGIC;
         Z: out STD_LOGIC);
  end;

  architecture synth of mealy is
    type statetype is (A, B, C, D, E);
    signal state, nextstate: statetype;
  begin

    -- state register
    process(clk, reset)
    begin
      if reset = '1' then
        state <= 0;
      elsif clk'event and clk = '1' then
        state <= nextstate;
      end if;
    end process;

    -- next state logic
    process(state, X)
    begin
      case state is
        when A =>
          if X = '0' then nextstate <= B;
          else nextstate <= C;
          end if;
        
        when B =>
          if X = '0' then nextstate <= D;
          else nextstate <= E;
          end if;

        when C =>
          if X = '0' then nextstate <= E;
          else nextstate <= D;
          end if;

        when others => nextstate <= A;
      end case;
    end process;

    -- output logic
    Z <= '1' when (state = E and X = '1') else '0';
  end;

#+end_src

** Intra A14 - Q3

*** Question 3 a)

Supposons que les implémentations de deux modules ~modFSM~ et ~lightsFSM~ existent déjà

#+begin_src vhdl

  -- modFSM.vhd

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity modFSM is
    port(P, R: in STD_LOGIC;
         clk: in STD_LOGIC;
         M: out STD_LOGIC);
  end;

  -- arch ...

#+end_src

#+begin_src vhdl

  -- lightsFSM.vhd

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity lightsFSM is
    port(Ta, Tb, M: in STD_LOGIC;
         clk: in STD_LOGIC;
         La, Lb: out STD_LOGIC_VECTOR(2 downto 0));
  end;

  -- arch ...

#+end_src

Écrire un *modèle structurel* du module ~controllerFSM~ dont le schéma est comme suit:

[[/home/phil-gab99/Documents/Notes/Demo/IFT-1227/intra/intra.org_20220317_025601_mlz5SI.png]]

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity controllerFSM is
  -- TODO
  end controllerFSM;

  architecture synth of controllerFSM is
  begin
  -- TODO
  end synth;

#+end_src

**** Solution

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity controllerFSM is
    port(P, R, Ta, Tb: in STD_LOGIC;
         clk: in STD_LOGIC;
         La, Lb: out STD_LOGIC_VECTOR(2 downto 0));
  end;

  architecture synth of controllerFSM is
    component modFSM
      port(P, R: in STD_LOGIC;
           clk: in STD_LOGIC;
           M: out STD_LOGIC);
    end component;

    component lightsFSM
      port(Ta, Tb, M: in STD_LOGIC;
           clk: in STD_LOGIC;
           La, Lb: out STD_LOGIC_VECTOR(2 downto 0));
    end component;

    signal M_ctlFSM: STD_LOGIC;
  begin
    modFSM_q3a: modFSM port map(P, R, clk, M_ctlFSM);
    lightsFSM_q3a: lightsFSM port map(Ta, Tb, M_ctlFSM, clk, La, Lb);
  end;

#+end_src

*** Question 3 b)

Codez un module VHDL *comportemental* d'un circuit implémentant les trois fonctions logiques définies par les équations booléennes suivantes:

$F_1 = A \oplus B$
$F_2 = ABC + \overline A \ \overline B D$
$F_3 = ABCD + \overline A \ \overline B C D$

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity q3b is
  -- TODO
  end q3b;

  architecture synth of q3b is
  begin
  -- TODO
  end synth;

#+end_src

**** Solution

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity circuit_q3b is
    port(A, B, C, D: in STD_LOGIC
         F1, F2, F3: out STD_LOGIC);
  end;

  architecture synth of circuit_q3b is
  begin
    F1 <= A xor B;
    F2 <= (A and B and C) or ((not A) and (not B) and D);
    F3 <= (A and B and C and D) or ((not A) and (not B) and C and D)
  end;

#+end_src

** Intra A14 - Q4

Considérer le code VHDL de la machine à états finis suivant:

#+begin_src vhdl

  library IEEE;
  use IEEE.std_logic_1164.all;

  entity fsm1 is
    port (clk, reset: in STD_LOGIC;
          a, b: in STD_LOGIC;
          z : out STD_LOGIC);
  end;

  architecture synth of fsm1 is
    type statetype is (S0, S1, S2, S3);
    signal state, nextstate: statetype;
    signal ab: STD_LOGIC_VECTOR(1 downto 0);
  begin

    -- state register
    process (clk, reset)
    begin
      if reset = ‘1’ then state <= S0;
      elsif clk’event and clk = ‘1’ then state <= nextstate;
      end if;
    end process;

    -- next state logic
    ab <= a & b;
    process (all)
    begin
      case state is
        when S0 =>
          case (ab) is
            when "00" => nextstate <= S0;
            when "01" => nextstate <= S0;
            when "10" => nextstate <= S3;
            when "11" => nextstate <= S1;
            when others => nextstate <= S0;
          end case;

        when S1 =>
          case (ab) is
            when "00" => nextstate <= S0;
            when "01" => nextstate <= S2;
            when "10" => nextstate <= S3;
            when "11" => nextstate <= S1;
            when others => nextstate <= S0;
          end case;

        when S2 =>
          case (ab) is
            when "00" => nextstate <= S0;
            when "01" => nextstate <= S2;
            when "10" => nextstate <= S3;
            when "11" => nextstate <= S1;
            when others => nextstate <= S0;
          end case;

        when S3 =>
          case (ab) is
            when "00" => nextstate <= S0;
            when "01" => nextstate <= S2;
            when "10" => nextstate <= S3;
            when "11" => nextstate <= S1;
            when others => nextstate <= S0;
          end case;

        when others => nextstate <= S0;
      end case;
    end process;

    -- output logic
    process(all)
    begin
      case state is
        when S0 =>
          if ab = “11” then z <= '1';
          else z <= '0';
          end if;

        when S1 =>
          if ab = “00” then z <= '0';
          else z <= '1';
          end if;

        when S2 =>
          if ab = “11” then z <= '1';
          else z <= '0';
          end if;

        when S3 =>
          if ab = “00” then z <= '0';
          else z <= '1';
          end if;

        when others => z <= '0';
      end case;
    end process;
  end;

#+end_src

*** Question 4 a)

La machine codée est-elle de type Moore ou Mealy? et pourquoi?

**** Solution

Machine de type *Mealy* - Le output dépend de l'état présent *ET* du input

*** Question 4 c)

Dans le bout de code ici-bas, identifier le mécanisme de synchronisation du sigal ~reset~, puis montrer le code avec la synchronisation différente de celle trouvée.

#+begin_src vhdl

  process(clk, reset)
  begin
    if reset = '1' then state <= S0;
    elsif clk'event and clk = '1' then state <= nextstate;
    end if;
  end process;

#+end_src

**** Solution

Asynchrone - Un changement dans ~reset~ est immédiatement refléter sur le signal ~state~

Ci-bas le mécanisme synchrone:

#+begin_src vhdl

  process(clk)
  begin
  -- Reset vérifier seulement au rising edge de clk
    if clk'event and clk = '1' then
      if reset = '1' then state <= S0;
      else state <= nextstate;
      end if;
    end if;
  end process;

#+end_src

* MIPS

** Exercice 6.20

Convertir la procédure haut-niveau de l'exercice 6.18 en assembleur MIPS

Rappel:

#+begin_src c

  

#+end_src

