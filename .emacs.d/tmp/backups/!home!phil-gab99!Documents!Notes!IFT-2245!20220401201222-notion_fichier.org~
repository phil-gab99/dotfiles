:PROPERTIES:
:ID:       0dc4e847-b544-4145-8982-1e21b5fa17f7
:END:
#+title: ift2245-notion-fichier
#+STARTUP: latexpreview inlineimages
#+date: [2022-04-01 Fri 20:12]

* Notion de fichier

Du point de vue de l'utilisateur, un fichier est le plus petit lot de stockage secondaire logique
Types de fichiers:
- Les données
  - Numérique
  - Caractère
  - Binaire
- Les programmes

* Attributs d'un fichier

- *Nom* $\Rightarrow$ Seuls informations conservées sous une forme lisible par l'humain
- *Identifiant* $\Rightarrow$ Le tag (numéro) unique identifiant le fichier dans le système de fichiers
- *Type* $\Rightarrow$ Nécessaire pour les systèmes prenant en charge différents types
- *Emplacement* $\Rightarrow$ Pointeur vers l'emplacement du fichier sur le materiel
- *Taille* $\Rightarrow$ Taille actuelle du fichier (taille sur disque = $N \times$ taille de bloc)
- *Protection* $\Rightarrow$ Contrôle qui peut lire, écrire, exécuter
- *Heure, date et identification de l'utilisateur* $\Rightarrow$ Données pour la protection, la sécurité et la surveillance de l'utilisation
- Les informations sur les chiers sont conservées dans la structure du répertoire, qui est stockée sur le disque

* Opérations sur fichiers

- *Créer* $\Rightarrow$ Généralement commence vide
  - Trouver de l'espace dans le système de fichiers
  - Faire une nouvelle entrée dans le répertoire
- *Ouvrir* $\Rightarrow$ Trouver un fichier et le mettre dans la mémoire centrale
- *Lire* $\Rightarrow$ Lire un certains nombre de bytes d’un fichier
  - Le /read pointer/ indique l'emplacement dans le fichier où la lecture suivante doit avoir lieu
  - ~syscall~ $\Rightarrow$ ~read(pos, size)~ (accès direct) ou ~read(size)~ (accès séquentielle)
- *Fermer* $\Rightarrow$ Indiquer qu’on a finit d’opérer
- *Écrire* $\Rightarrow$ Écrire par dessus, ou étendre un fichier - Déplacer le contenu en mémoire vers le disque (si celui-ci a changé - revoir le [[id:96735a35-a041-4af6-86b1-a2aff1f73f89][dirty bit]])
  - Le write pointer indique l'emplacement dans le fichier où l'écriture suivante doit avoir lieu
  - ~syscall~ $\Rightarrow$ ~write(pos, size, bptr)~ (accès direct) ou ~write(size, bptr)~ (accès séquentiel)
- *Repositionner* $\Rightarrow$ Les /read and write pointers/ peuvent changer - Appelé une ~seek~: ~syscall seek(pos)~
- *Supprimer* $\Rightarrow$ Libère tout l'espace fichier
  - Effacer l'entrée du répertoire
- *Tronquer* $\Rightarrow$ Effacer une partie de la fin du ficher (ne doit pas le recréer)

** Accès séquentiel

#+begin_src c

  fd = open("file.txt",...);
  read(fd,...);
  write(fd,...);
  lseek(fd,...);
  close(fd,...);

#+end_src

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220401201222-notion_fichier.org_20220401_202749_tX9BwS.png]]

** Accès directe

#+begin_src c

  fd = open("file.txt",...);
  buf = mmap(..., fd,...);
  /* modifier buf */
  buf = munmap(..., fd,...);
  close(fd,...);

#+end_src

Utile pour un accès immédiat à de grandes quantités d'informations
- Ex.: Des bases de données
Faire des accès séquentiels sur un système d'accès direct n'est pas très efficace

** Fichiers "memory-mapped"

- Rendre un fichier accessible comme une partie de la mémoire
- Un fichier est initialement lu en utilisant la pagination sur demande
  - Une partie du fichier de la taille d'une page est lue du système de fichiers et est mis dans une page physique (frame)
  - Les lectures/écritures suivantes vers/depuis le fichier sont traitées comme des accès mémoire ordinaires
- Simplifie et accélère l'accès aux fichiers en générant des E/S de fichiers via la mémoire au lieu des appels système ~read()~ et ~write()~
- Permet également à plusieurs processus de mapper le même fichier permettant de partager les pages en mémoire
- Les données écrites le rendent sur le disque
  - Périodiquement et/ou lors d'un ~close()~ (COW - /Copy on write/)

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220401201222-notion_fichier.org_20220401_204828_iOjIlH.png]]

** Pourquoi Open/Close

- Permet de séparer les opérations coûteuses
  - Recherche dans les répertoires
  - Trouver les méta-données du ficher
  - Verifications des droits d’accès
- Permet aussi de maintenir un état entre plusieurs opérations
  - Éviter d’effacer un ficher en cours d’usage
  - Garder un pointer vers la position courante (~read~ et ~write~)
  - Éviter l’accès concurrent (locking)
- Le SE maintient un ~open file table~ qui contient des informations sur tous les fichiers ouverts
  - Quand une opération de fichier est demandée, le fichier est spécifié via un index dans ce tableau (pas besoin de chercher le répertoire)
  - Un tableau par processus et une pour la système

** Informations associées à un fichier ouvert

*File pointers* $\Rightarrow$ ~read~ et ~write~ (*par les processus*)
*File-open count* $\Rightarrow$ Tenir un compte du nombre de processus qui ont ouvert le fichier (*par le système*)
*Emplacement du fichier sur le disque* $\Rightarrow$ Les informations nécessaires pour localiser le fichier sur le disque sont conservées en mémoire afin que le système n'aie pas à le lire depuis le disque pour chaque opération (*par le système*)
*Des droits d’accès* (*par les processus*)

** Synchronisation - Verrouillage

Deux approches:
- *Obligatoire* $\Rightarrow$ Accès interdit si on n’a pas le verrou
• *Consultatif* $\Rightarrow$ Les verrous sont là, peuvent être utilisées ou non

*Verrou partagée* $\Rightarrow$ Pour lecteur (plusieurs processus peuvent acquérir le verrou simultanément)
*Verrou exclusif* $\Rightarrow$ Pour écriture (un seul processus peut l’acquérir à la fois)

Peut verrouiller:
- Le contenu d’un fichier
- Le nom d’un fichier (i.e. une entrée de répertoire)
- Une partie d’un ficher
