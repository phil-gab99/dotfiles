#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline \n:t
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: IFT-1227 Demo 9
#+date: <2022-03-24 Thu>
#+author: Philippe Gabriel
#+email: philippe.gabriel.1@umontreal.ca
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.0.91 (Org mode 9.5.2)
#+cite_export:

* Révision

** Exercice 6.17

Implémenter en MIPS en utilisant ~slt~. On suppose que ~g~ et ~h~ correspondent aux registres ~$s0~ et ~$s1~

#+begin_src c

  // a)

  if (g > h)
      g = g + h;
  else
      g = g - h;

#+end_src

#+begin_src c

  // b)

  if (g >= h)
      g = g + 1;
  else
      h = h - 1;

#+end_src

#+begin_src c

  // c)

  if (g <= h)
      g = 0;
  else
      h = 0;

#+end_src

** Solution

#+begin_src mips

  # a)

  main:   addi        $s0, $s0, 5         # g = 5
          addi        $s1, $s1, 3         # h = 3

          slt         $t0, $s1, $s0       # t0 = 1 si g > h, t0 = 0 si g <= h

          beq         $t0, $0, else       # t0 == 0 alors brancher
          add         $s0, $s0, $s1       # g = g + h
          j           endif

  else:   sub         $s0, $s0, $s1       # g = g - h
  endif: 

#+end_src

#+begin_src mips

  main:   addi        $s0, $s0, 3         # g = 3
          addi        $s1, $s1, 3         # h = 3

          slt         $t0, $s0, $s1       # t0 = 0 quand g >= h, t0 = 1 quand g < h

          bne         $t0, $0, else 
          addi        $s0, $s0, 1         # g++
          j           endif

  else:   subi        $s1, $s1, 1         # addi $s1, $s1, -1, h--
  endif: 

#+end_src

#+begin_src mips

  main:   addi        $s0, $s0, 3         # g = 3
          addi        $s1, $s1, 3         # h = 3

          slt         $t0, $s1, $s0       # t0 = 1 si g > h, t0 = 0 si g <= h
          bne         $t0, $0, else
          move        $s0, $0
          j           endif

  else:   move        $s1, $0
  endif:

#+end_src


#+begin_src mips

  addiu       $t0, $0, 5
  addiu       $t0, $0, -5

          lui         $s0, 8
          # s0 <- 0000 0000 0000 1000 0000 0000 0000 0000

#+end_src

#+begin_src c

  int sum(int a, int b) { // PC <- cette ligne
      return a + b; // jr $ra
  }

  int main() {
      printf("%i", sum(4, 5));  // PC à cette ligne, $ra <- PC
  }


#+end_src

#+begin_src python

  # test.py

  def sum(a, b):
      return a + b # jr $ra

  s = sum(4, 5)  # jal sum(4, 5), $ra <- cette ligne, PC <- ligne de sum
  # s = 9
  print(s)

  # python test.py

#+end_src
