:PROPERTIES:
:ID:       7b8d7340-860b-4612-81e6-b0dedef4bb71
:END:
#+title: ift2245-solution-section-critique
#+STARTUP: latexpreview inlineimages
#+date: [2022-02-06 Sun 00:45]

* Solution au problème de section critique

Une solution de la problème de section critique devrait avoir les propriétés suivantes

1. *Exclusion mutuelle*
   - Si un processus (thread) $P_i$  est dans une section critique, aucun autre processus (thread) ne peut interférer

2. *Progrès*
   - Si aucun processus ne s'exécute dans sa section critique et qu'il existe des processus qui souhaitent entrer dans leur section critique, seuls les processus qui ne sont pas dans leur section restante (/remainder section/) peuvent participer à la *sélection du processus* qui entrera dans sa section critique suivante
   - La sélection ne peut pas être reportée indéfiniment

3. *Attente limitée* - Bounded waiting
   - Une limite doit exister sur le nombre de fois que les autres processus sont autorisés à entrer dans leurs sections critiques après qu'un processus a fait une demande pour entrer dans sa section critique et avant que cette demande soit accordée

On suppose que chaque processus s'exécute à une *vitesse non-nulle*
On ne dispose d'aucune hypothèse concernant la vitesse relative des *n* processus

** Solution de Peterson

Solution pour deux prorcessus en exécution alternative (alternance entre /critical section/ et /remainder section/)
Les deux processus partagent deux variables:
- ~int turn~ - Indique à quel processus est permis passage dans sa section critique
- ~boolean flag[2]~ - Tableau pour indiquer si un processus est *prêt à entrer* dans la section critique

#+begin_src c

  do {
      // Politique de "politesse" - Dire qu'on est prêt et donner le tour à l'autre
      flag[i] = true; // Processus i est prêt à entrer dans sa section critique
      turn = j;       // Il donne le tour au processus j, si il est prêt alors il entre dans sa section critique
      // Processus i est potentiellement bloqué ici
      while (flag[j] && turn == j); // j est dans sa section critique, à la fin de celle-ci il met sont flag à faux
      // Critical section de i
      flag[i] = false;              // i met sont flag à faux à la fin de sa section critique - Exit section
      // Remainder section de i
  } while (true);

#+end_src

Il est prouvable que
- L'exclusion mutuelle est conservé - Garantie par la variable ~turn~ qui peut soit être ~j~ ou ~i~ (i.e. booléenne)
- Le progrès est satisfait - ~i~ indique dans le /exit section/ de sa section critique qu'il n'est plus prêt à entrer dans sa section critique, ~flag[i] = false~
- L'attente limitée est satisfaite - Par nos hypothèses et le fait que chaque processus donne le tour à l'autre lorsqu'il est prêt
