:PROPERTIES:
:ID:       1ba6e8bf-a03b-4e1e-bc11-f226647233ed
:END:
#+title: ift6755-symbolic-model-checking
#+STARTUP: latexpreview inlineimages
#+date: [2022-03-30 Wed 09:16]

* Symbolic Model Checking

- Saves us from constructing a model state space explicitly - Effective "cure" for state space explosion
- Set of states and the transition relation are represented by formulas - Set operations are defined in terms of formula manipulations
- Reduced Ordered Binary Decision Trees (ROBDDs) - Allow for efficient storage and manipulation of logic formulas
- Example $x \land y$
[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_091919_TYk94i.png]]

* Representing Models Symbolically

- A system state represents an interpretation (truth assignment) for a set of propositional variables $V$

  Formulas represent sets of states that satisfy it

  False = $\emptyset$, True = $S$
  - $f_1$ - Set of states in which $f_1$ is true - $\{s_0, s_1\}$
  - $f_2$ - Set of states in which $f_2$ is true - $\{s_2, s_3\}$
  - $f_1 \lor f_2 = \{s_0, s_1, s_2, s_3\} = S$

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_092157_tn3UkN.png]]

- State transitions are described by relations over two sets of variables: $V$ (source state) and $V'$ (destination state)
  - Transition $(s_2, s_3)$ is $\lnot b_1 \land \lnot b_2 \land \lnot f_1 \land f_2 \land b_1' \land \lnot b_2' \land \lnot f_1' \land f_2'$
  - Relation $R$ is described by *disjunction* of formulas for individual transitions

** Boolean Functions

Boolean functions: $\mathcal B = \{0, 1\}$ - $f: \mathcal B \times \dots \times \mathcal B \to \mathcal B$
Boolean expressions: $t ::= x \ | \ 0 \ | \ 1 \ | \lnot t \ | \ t \land t \ | \ t \lor t \ | \ t \to t \ | \ t \gets t$

Truth assignments - $\rho$  $[v_1/ x_1, v_2/x_2, \dots, v_n/x_n]$
Satisfiable - Exists $\rho$ s.t. $t[\rho]$ = 1
Tautology - Forall $\rho$, $t[\rho]$ = 1

** Combinatorial Circuits

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_093232_V6DyCF.png]]

- Are these circuits equivalent
- Do they represent a tautology
- Are they satisfiable

** Representing Boolean Functions

| Representation of boolean functions | compact?  | SAT? | validity | land   | lor    | lnot |
|-------------------------------------+-----------+------+----------+--------+--------+------|
| Propositional formulas              | Often     | Hard | Hard     | Easy   | Easy   | Easy |
| Formulas in DNF                     | Sometimes | Easy | Hard     | Hard   | Easy   | Hard |
| Formulas in CNF                     | Sometimes | Hard | Easy     | Easy   | Hard   | Hard |
| Ordered truth tables                | Never     | Hard | Hard     | Hard   | Hard   | Hard |
| ROBDDs                              | Often     | Easy | Easy     | Medium | Medium | Easy |

** Basic Idea - Shannon Expansion

Definition $x \to y_0, y_1 \overset{\mathrm{def}} = (x \land y_0) \lor (\lnot x \land y_1)$
- $x$ is the test expression of an if-then-else

- INF (if-then-else normal form) - All formulas can be represnted using /if-then-else/ on unnegated variables and constants 0 (false) and 1 (true)
- Shannon expansion of $t$ with respect to $x$ - $t = x \to t[1/x], t[0/x]$ (substitution of $x$ by 0 or 1)

*** Example

$t = (x_1 \equiv y_1) \land (x_1 \equiv y_2)$
Task - Represent in INF with order $x_1 < y_1 < x_2 < y_2$
- $t = x_1 \to t_1, t_0$
- $t_0 = y_1 \to t_{01}, t_{00}$ so $t_0 = y_1 \to 0, t_{00}$
  - $x_1 = 0, y_1 = 1; \quad \therefore x_1 \equiv y_1 = 0$
- $t_1 = y_1 \to t_{11}, 0$
  - $x_1 = 1, y_1 = 0; \quad \therefore x_1 \equiv y_1 = 0$
- $t_{00} =x_2 \to t_{001}, t_{000}$
- $t_{11} =x_2 \to t_{111}, t_{000}$
- $t_{000} =y_2 \to 0, 1$
  - $x_1 = 0, y_1 = 0, x_2 = 0$
- $t_{001} =y_2 \to 1, 0$
  - $x_1 = 0, y_1 = 0, x_2 = 1$
- $t_{110} =y_2 \to 0, 1$
  - $x_1 = 1, y_1 = 1, x_2 = 0$
- $t_{111} =y_2 \to 1, 0$
  - $x_1 = 1, y_1 = 1, x_2 = 1$

Decision tree:
[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_095409_X8SHHV.png]]

** OBDD

Lots of common subexpressions - Can eliminate redundancy
[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_095506_rhZRCj.png]]

OBDD for $t =(x_1 \equiv y_1) \land (x_2 \equiv y_2)$ with ordering $x_1 < y_1 < x_2 < y_2$
[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_095638_YXs139.png]]

Informal definition - Binary Decision Diagram (BDD) - directed acyclic graph of boolean expressions
If along every branch variables occur in the same order, it is called an Ordered Binary Decision Diagam (OBDD)

** ROBDD

An OBDD without and redundant is called a *Reduced Ordered BD*
- Which of these tests are redundant:
  [[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_095824_CEp5ud.png]]

- Definition: A *Binary Decision Diagram* is a rooted, directed, acyclic graph $(V, E)$
  - $V$ contains (up to) two terminal vertices, $0, 1 \in V, V \in V \textbackslash \{0, 1\}$ are non terminal and have attributs var($v$), low($v$), high($v$)
- A BDD is *ordered* if on all paths from the root the variables respect a given total order
- An OBDD is *reduced* if for all non-terminal vertices $u, v$, the following holds:
  1. low($u$) $\neq$ high($u$)
  2. low($u$) $=$ low($v$) $\land$ high($u$) = high($v$) $\land$ var($u$) = var($v$) $\to$ $u = v$

** Reducing OBDDs

Generate an OBDD for a Boolean function then *reduce* by recursively descending the OBDD

Outline

1. Eliminate *duplicate leaves*
   - Redirect all incoming edges to just one 0-leaf and one 1-leaf
2. Eliminatee *redundant tests* ("don't care" vertices)
   - If low($v$) $=$ high($v$) = $w$, deleete $v$ and redirect all its incoming edges to $w$
3. Eliminate *common subexpressions* (isomorphic subtrees)
   - If $v \neq w$ are roots of isomorphic subtrees, remove $w$ and redirects to $v$ all edges that are incoming to $w$

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_100757_Mjmytl.png]]

** Variable Ordering

ROBDD for $t = (x_1 \equiv y_1) \land (x_2 \equiv y_2)$
- With ordering $x_1 < y_1 < x_2 < y_2$

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_100907_0RlopU.png]]

- With ordering $x_1 < x_2 < y_1 < y_2$

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_100936_z7kztY.png]]

- The size of the ROBDD depends a lot on the variable ordering
- A good order can result in an exponentially smaller ROBDD
- Determining the optimal variable ordering is a hard problem (co-NP complete)
  - Checking whether a variable ordering is optimal is NP-hard

** ROBDD Canonicity

Lemma (Canonicity) - For any $n$ ary boolean function $f$, there exists a *unique* ROBDD $b$ with variable ordering $x_1 < x_2 < \dots < x_n$

Consequences:
- If $b$ is singleton node 1 ($B_1$), then $f$ is valid (a tautology)
- If $b$ is singleton node 0 ($B_0$), then $f$ is unsatisfiable
- If a $f$ does not depend on the value of $x_i$, then $x_i$ does not appear in $b$
- If $f$ and $g$ have ROBDDs $b_f$ and $b_g$ (with compatible variable orders):
  - $f \to g$ iff the ROBDD of $(f \land \lnot g)$ is $B_0$
  - $f \leftrightarrow g$ iff $b_f$ and $b_g$ are *isomorphic* (have the same structure)

** Apply Boolean operator

Given OBDDs $B_f$ and $B_g$ for boolean formulas $f$ and $g$, the algorithm $\mathit{apply}(\mathit{op}, B_f, B_g)$ computes the reduced OBDD of the boolean formula $\mathit{op}(f, g)$ where $\mathit{op}$ denotes any function from $\{0, 1\} \times \{0, 1\} \to \{0, 1\}$ (ex.: $\lor, \land$, xor)

Outline
1. Find the variable $v$ with the highest order which occurs in $B_f$ or $B_g$
2. Use *Shannon expansion* - Split the problem into two subproblems for $v = 0$ and $v = 1$ and solve recursively
3. At the leaves, apply the boolean operation $\mathit{op}$ directly
4. Reduce if necessary

** Restrict Boolean operator

$\mathit{restrict}(0, x, B_f)$ computes the ROBDD representing $f[0/x]$ and having the same variable ordering as $B_f$

Algorithm
1. For each node $n$ labelled with $x$
   - Redirect incoming edges to low($n$)
   - Remove $n$
2. Reduce if necessary

$\mathit{restrict}(1, x, B_f)$ is similar for $f[1/x]$ only we redirect incoming edges to high($n$)

** OBDD Manipulation

\begin{tabular}{r | l}
Boolean formula $f$ & OBDD $B_f$ \\
\hline
\hline
$0$ & $B_0$ \\
$1$ & $B_1$ \\
$x$ & $B_x$ \\
$\lnot f$ & Swap the 0-leaf and 1-leaf \\
$f \lor g$ & Apply($\lor, B_f, B_g$) \\
$f \land g$ & Apply($\land, B_f, B_g$) \\
$f[1/x]$ & Restrict($1, x, B_f$) \\
$f[0/x]$ & Restrict($0, x, B_f$) \\
$\exists x. f$ & Apply($\lor, B_{f[1/x]}, B_{f[0/x]}$) \\
$\forall x. f$ & Apply($\land, B_{f[1/x]}, B_{f[0/x]}$) \\
\end{tabular}

* Model-Checking Techniques (Symbolic)

BDD
- Express transition relation by a formula, represented as BDD - Manipulate that to compute logical operations
- Based on very fast decision diagram packages (ex.: CUDD)
SAT
- Expand transition relation a fixed number of steps (ex.: loop unrolling), resulting in a formula
- For this unrolling, check whether the property holds
- Continue increasing the unrolling until error is found, resources are exhausted, or diameter of the problem is reached
- Based on very fast SAT solvers

** Pros and Cons

- Often cannot express full requirements
  - Instead check several smaller properties
- Largely automatic and fast
- Few systems can be checked directly
  - Must generally abstract
- Work better for certain types of problems
  - Very useful for control-centered concurrent systems such as avionics software, hardware, communication protocols
  - Not very good at data-centered systems such as user interfaces and databases
- Better use for debugging rather than assurance
- Testing vs model-checking
  - Usually, find more problems by exploring *all* behaviours of a *downscaled* system than be testing *some* behaviours of the *full* system

** State of the art model-check SMV

Symbolic Model Verifier [Mc93]
- A model checker that uses symbolic model checking algorithm based on Decision Diagrams or SAT solvers
- Features
  - Can have synchronous or asynchronous parallelism
  - Model environment non-deterministically
  - Also use non-determinism for systems which are not fully implemented or are abstract models of complex systems
- Modern SMV variants
  - NuSMV (IRST)
  - Cadence SMV (Cadence)
  - SMV (CMU)

*** NuSMV

Cooperativee project
- Embedded Systems Unit in the Center for Information Technology at FBK-IRST
- Model Checking group at Carnegie Mellon University, the Mechanized Reasoning Group at University of Genova
â€¢ Mechanized Reasoning Group at University of Trento

Version 1 - implemented BDD-based model checking
Version 2 - Decouples the specification language from the underlying technique, can use both BDDs and SAT

Single process example

#+begin_src

  MODULE main
  VAR
          request :boolean;
          state   :{ready, busy};
  ASSIGN
          init(state) := ready;
          next(state) := case
                             request = TRUE :busy;
                             TRUE           :{ready, busy};
                         esac
  LTLSPEC
          G(request -> F state = busy)

#+end_src

- The variable ~request~ is not assigned
- This means that there are no constraints on its values - It can assume any value
- It models an unconstrained input to the system

[[/home/phil-gab99/Documents/Notes/IFT-6755/20220330091608-symbolic_model_checking.org_20220330_121103_c00btq.png]]
