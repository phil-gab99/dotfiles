:PROPERTIES:
:ID:       da3233df-96e6-4f64-be72-2e160787fd3d
:END:
#+title: ift2935-calcul-tuples
#+STARTUP: latexpreview inlineimages
#+date: [2022-01-31 Mon 18:55]


* Calcul de tuples

** Requête

- Une requête simple prend la forme $\{t \ | \ \mathtt{cond}(t)\}$ qui retourne les tuples $t$ satisfaisant la condition $\mathtt{cond}$
- Exemple: $\{t \ | \ \mathtt{employee}(t) \mathtt{and} t .\mathtt{salary} > 50000\}$
- Pour accéder aux attributs, on utilise la notation ~t.<attribut>~
$\{t.\mathtt{fname}, t.\mathtt{lname} \ | \ \mathtt{employee}(t) \ \mathtt{and} \ t.\mathtt{salary} > 50000\}$

- De façon informelle une requête est spécifiée comme suit:
  - Pour chaque variable de tuple il faut préciser le domaine de la relation ~R~ dont ~t~ est un tuple
  - Le domaine peut être précisé sous la forme $t \in R$ à l’extérieur de la formule de la requête ou sous ls forme $R(t)$ dans la requête
  - Par exemple
    $t \in \mathtt{employee}$∈ employee
    $t.\mathtt{fname}, t.\mathtt{name} \ | \ t.\mathtt{salary} > 50000$
- La condition détermine les tuples sélectionnés.

** Spécification

Un tuple $t$ prend de la forme $(t_1, \dots, t_n)$
- Pour chaque variable de tuple $t_i$ il y a une contrainte de domaine $t_i \in R_i$
- Pour chaque $t_i$ la requête peut référer à plusieurs $t_i \cdot A_{ij}$ où $A_{ij}$ est un attribut de $t_i$
- La condition est de la forme $F(t_1, \dots, t_n)$ où $F$ est une formule logique qui peut faire intervenir n'importe quel attributs des $t_i$
- Une requête prend la forme:

  $\{\dots t_i \cdot A_{ij} \dots \ | \ F(t_1, \dots, t_n)\}$

Une *formule atomique* prend la forme $t_i \cdot A \ \mathtt{op} \ t_j \cdot B$
- Où $A$ est attribut de $t_i$ et $B$ attribut de $t_j$ ou encore la forme $t_i \cdot A \ \mathtt{op} \ c$ ou $c \ \mathtt{op} \ t_i \cdot A$ avec $c$ une constante et $\mathtt{op}$ est un opérateur parmi $\{=, <, \leq, >, \geq, \neq\}$

- Les formules sont construites à partir des formules atomiques en utilisant les opérateurs logiques et les quantificateurs
  - Les formules atomiques sont des formules
  - Si $F_1$ et $F_2$ sont des formules, il en est de même de $(F_1 \ \mathtt{AND} \ F_2)$, $(F_1 \ \mathtt{OR} \ F_2)$ et $(F_1 \ \mathtt{NOT} \ F_2)$
  - On définit la notion de *variable libre*
  - Si $F$ est une formule font $t$ est variable libre alors $(\exists t)(F)$ et $(\forall t)(F)$ sont des formules et font de $t$ une *variable liée*
    - $(\exists t)(F)$ retourne ~TRUE~ s'il y a au moins un tuple qui satisfait la formule $F$
    - $(\forall t)(F)$ retourne ~TRUE~ si tous les tuples satisfont $F$
- $(\forall t) (F) \equiv \mathtt{NOT} (\exists t) (\mathtt{NOT} F)$

** Exemple

*** Exemple 1

Listex les nom et adresses des employés qui travaillent pour le département ~research~

$t \in$ ~employee~, $d \in$ ~department~
$\{t.\mathtt{fname}, t.\mathtt{lname}, t.\mathtt{address} \ | \ \exists(d) (d.\mathtt{dname} = '\mathtt{Research}' \ \mathtt{and} \ d.\mathtt{dnumber} = t.\mathtt{dno})\}$

- Requête SQL
#+begin_src sql

  SELECT t.fname, t.lname, t.address
  FROM employee AS t
  WHERE EXISTS (SELECT * FROM department d
                WHERE d.name = 'Research' and d.dnumber = t.dno)

#+end_src

*** Exemple 2

Pour tous les projets du site Stafford, lister le numéro du projet, le numéro du département qui le gère, le nom, la date d enaissance et l'adresse du gérant du département.
On suppose les schémas suivants:

~project(pname, _pnumber_, plocation, dnum)~
~department(dname, _dnumber_, mgrssn, mgrstartdate)~
~employee(fname, lname, bdate, ssn, ...)~

La requête se formule ainsi:
$p \in \mathtt{project}, d \in \mathtt{department}, m \in \mathtt{employee}$
$\{p.\mathtt{pnumber}, p.\mathtt{pdnum}, m.\mathtt{lname}, m.\mathtt{bdate}, m.\mathtt{address} \ | \ p.\mathtt{plocation} = '\mathtt{Stafford}' \ \mathtt{and} \ (\exists d)(\p.\mathtt{dnum} = d.\mathtt{dnumber} \ \mathtt{and} d.\mathtt{mgrssn} = m.\mathtt{ssn})\}$

- Requête SQL

#+begin_src sql

  SELECT p.pnumber, p.dnum, m.lname, m.bdate, m.address
  FROM project AS p, employee AS m
  WHERE p.plocation='Stafford' AND
  EXISTS (SELECT * FROM department AS d
          WHERE p.dnum = d.dnumber AND d.mgrssn = m.ssn);

#+end_src

** Requêtes avec quantificateurs universels

- Lister les noms des employés qui travaillent sur tous les projets contrôlés par le département 5 (i.e. ~dnum = 5~) sachant que:
  ~project(pname, _pnumber_, plocation, dnu)~
  ~employee(fname, lname, _ssn_, ...)~
  ~works_on(_essn_, _pno_, hours)~
  - ~essn~ réfère à ~ssn~ et ~pno~ réfère à ~pnumber~

Si on avait l'implication, on écrirait (avec $\land$ pour ~AND~ et $\lor$ pour ~OR~)

$\{e.\mathtt{lname}, e.\mathtt{fname} \ | \ \mathtt{employee}(e) \land (\forall p) ((\mathtt{project}(p) \land p.\mathtt{dnum} = 5) \implies (\exists w) (\mathtt{works_on}(w) \land (w.\mathtt{essn} = e.\mathtt{ssn} \land (p.\mathtt{pnumber} = w.\mathtt{pno}))))\}$

Sachant que $(\forall p)(A \implies B) \equiv \lnot (\exists p)(A \land \lnot B), on peut réécrire:

$\Bigg \{e.\mathtt{lname}, e.\mathtt{fname} \ | \ \mathtt{employee}(e) \land \lnot \Big ( (\exists p) ((\mathtt{project}(p) \land p.\mathtt{dnum} = 5) \land \lnot (\exists w) (\mathtt{works_on}(w) \land (w.\mathtt{essn} = e.\mathtt{ssn} \land (p.\mathtt{pnumber} = w.\mathtt{pno})))) \Big)\Bigg\}$
- Requête SQL

#+begin_src sql

  SELECT e.lname, e.fname FROM employee e
  WHERE NOT EXISTS (SELECT * FROM project p
                    WHERE p.dnum AND NOT EXISTS (SELECT * FROM works_on w
                                                 WHERE w.essn = e.ssn AND p.pnumber = w.pno))
#+end_src
