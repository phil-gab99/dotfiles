:PROPERTIES:
:ID:       0b1f0035-c6db-46c0-a8d1-a80f063ef44b
:END:
#+title: ift2245-memoire-virtuelle-intro
#+STARTUP: latexpreview inlineimages
#+date: [2022-03-16 Wed 11:33]

* Introduction

*Mémoire virtuelle* $\Rightarrow$ Séparation de la mémoire logique et de la mémoire physique
- Juste *une partie* du programme doit être en mémoire pour l'exécution
- L'espace d'adressage logique peut donc être beaucoup *plus grand* que l'espace d'adressage physique
- Permet aux espaces d'adresses physique d'être partagés par plusieurs processus
- Permet une création de processus plus efficace (ex.: avec ~fork()~)
- Plus de programmes fonctionnant simultanément
- Moins de I/O nécessaire pour changer ou swapper des processus

La mémoire virtuelle peut fonctionner avec un système de:
- Pagination à la demande
- Segmentation à la demande

[[/home/phil-gab99/Documents/Notes/IFT-2245/20220316035528-memoire_virtuelle.org_20220316_103615_mHOVka.png]]

** Espace d'adressage virtuel

- Espace d'adressage avec des trous
- Trous pour faciliter les allocations futures:
  - Agrandir la pile
  - Librairies liées dynamiquement
- Pages partagées avec d'autres processus
- Pas efficace d'avoir les trous dans la mémoire physique

[[/home/phil-gab99/Documents/Notes/IFT-2245/20220316035528-memoire_virtuelle.org_20220316_103806_SQJZl2.png]]

*** Librairie partagée

[[/home/phil-gab99/Documents/Notes/IFT-2245/20220316035528-memoire_virtuelle.org_20220316_103855_KZ6QAP.png]]

** Concepts fondamentaux pour la VM (Virtual Memory)

1. Pagination *à la demande*
   - Nous pouvons charger les pages (frames) lorsque nous en avons besoin
2. Remplacement de *pages* (par processus)
   - Le *total* de la mémoire de tous les processus *chargés* peut être *plus grand* que la mémoire physique
   - Si nous manquons d'espace phyisique, nous échangeons une *page* sur le disque dur

*** Pagination à la demande

- Option 1 - Mettre tout le processus en mémoire au moment du chargement
- Option 2 (*Pagination à la demande totale*) - N'apporter une page en mémoire que lorsque c’est nécessaire
  - Accès mémoire $\Rightarrow$ Besoin d’une page? fait le référence:
    - En mémoire $\to$ Le CPU se charge de tout
    - Sinon, trap vers le SE
    - Si la référence est invalide $\to$ abort!
    - Autrement, charger la page du disque en mémoire et réessayer
  - “Lazy swapper” - N'échange jamais une page en mémoire à moins que la page ne soit nécessaire
    - “Swapper $\to$ processus”, “Pager $\to$ pages”
  - Avantages:
    - Moins de I/O
    - Moins de mémoire utilisée
    - Réponse plus rapide $\to$ Plus de processus en mémoire
- Option 3 - Dans le milieu

**** Option 1 - Swapping

[[/home/phil-gab99/Documents/Notes/IFT-2245/20220316035528-memoire_virtuelle.org_20220316_104657_wuCADo.png]]

**** Option 2 - Pagination à la demande

***** Bit valide/invalide

Avec chaque entrée de table de page, un bit valide/invalide est associée:
- ~v~ $\to$ Dans la mémoire centrale (memory resident)
- ~i~ $\to$ Pas de la mémoire centrale
  - Valide mais pas dans la mémoire
  - Invalide (pas dans l'espace d'aadressage logique du processus)
Pendant la traduction d'adresse, si le bit valide/invalid dans l'entrée de la table de page est ~i~ $\to$ Erreur de page (Page fault)

[[/home/phil-gab99/Documents/Notes/IFT-2245/20220316035528-memoire_virtuelle.org_20220316_105222_HFL73o.png]]

Tableau de pages avec pages manquantes:

[[/home/phil-gab99/Documents/Notes/IFT-2245/20220316035528-memoire_virtuelle.org_20220316_105310_hvWLEB.png]]

***** Page fault

Le CPU utilise le tableau des pages pour trouver l'adresse physique
- Si le tableau des pages indique une entrée invalide $\to$ Page fault!
- Le CPU passe en *mode noyau* et appelle le SE
- Le SE fait une recherche dans sa propre table
  - Si l'adresse logique est vraiment invalide - Terminaison du processus
  - Sinon, trouver un frame libre
    - Transférer la page sur le disque vers ce frame en mémoire
    - Mettre à jour le tableau des pages
    - Réexécuter l'instruction du programme

***** Pagination à la demande

Cas extrême - Aucune page en mémoire au début
- Le SE met le PC à la première instruction du processus $\to$ Page fault (pour chaque processus)

Difficulté - Une instruction peut accéder à plusieurs pages
- Rare en raison de la *localité de référence*

Matériel requis pour la pagination sur demande
- MMU avec des bits valide/invalide par page
- Une mémoire secondaire
- La capacité de réexécuter une instruction
  - Instructions atomiques
  - Garder trace de la partie déjà exécutée

***** Coût d'un page fault

- Trap au système d'exploitation
- Enregistrer le PCB
- Déterminer que l'interruption était une page fault
- Vérifier que la référence de la page était légale et déterminer l'emplacement de la page sur le disque
- *Émettre une lecture à partir du disque à un frame libre*
  - Attendre dans une file d'attente pour ce périphérique jusqu'à ce que la demande de lecture soit traitée
  - Attendre le temps de latence pour trouver le frame sur le disque dûr
  - Transfert de la page vers un frame libre
• En attendant, allouez le CPU à un autre utilisateur
• Recevoir une interruption du système de I/O de disque (I/O terminé)
- Enregistrer le PCB pour l'autre utilisateur
- Déterminer que l'interruption provient du disque
- Corriger le tableau des pages et les autres tableaux pour affiher que la page est maintenant en mémoire
- Attendre que le processeur soit à nouveau alloué à ce processus
- Restaurer le PCB et le nouveau tableau de pages, puis reprendre l'instruction interrompue

***** Temps d'accès effectif

Taux de "page faults" - $0 \leq p \leq 1$
- $p = 0$ - Pas de page faults
- $p = 1$ - Toutes les références sont des pages faults

Effective Access Time (EAT):

$\mathrm{EAT} = (1 - p) \times \mathrm{memory\_access\_time} + p \times (\mathrm{page\_fault\_overhead} + \mathrm{swap\_page\_in} + \mathrm{restart\_overhead})$

***** Exemple

Temps d'accès à la mémoire centrale $\to$ 200 nanosecondes
Temps de service d'un page fault $\to$ 8 millisecondes (8 000 000 nanosecondes)

\begin{align*}
\mathrm{EAT} & = (1 - p) \times 200 + p \times 8 \ 000 \ 000 \\
& = 200 + p \times 7 \ 999 \ 800
\end{align*}

- 1 "miss" par 1000 accès:

  ???
